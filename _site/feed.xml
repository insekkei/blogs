<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>web前端笔记</title>
    <description>绿螘新醅酒，红泥小火炉。&lt;br&gt;晚来天欲雪，能饮一杯无？
</description>
    <link>http://insekkei.com/blogs//blogs/</link>
    <atom:link href="http://insekkei.com/blogs//blogs/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 19 Apr 2016 14:29:30 +0800</pubDate>
    <lastBuildDate>Tue, 19 Apr 2016 14:29:30 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>echarts多图时页面resize事件以及重绘需要判断</title>
        <description>&lt;h1 id=&quot;resize&quot;&gt;resize事件&lt;/h1&gt;

&lt;p&gt;当页面上有&amp;gt;1个图表时，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;window.onresize = myChart.resize;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并不能使所有的图响应浏览器resize事件，只有一个随机的图能随着resize。&lt;/p&gt;

&lt;p&gt;于是参考&lt;a href=&quot;https://facebook.github.io/react/tips/dom-event-listeners.html&quot;&gt;DOM Event Listeners in a Component&lt;/a&gt;里所写，添加了resize事件：&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
getInitialState() {
    let innerWidth = window.innerWidth;
    let acWidth;
    if (innerWidth &amp;gt; 991) {
        acWidth = (innerWidth - 144) / 3;
    }
    else {
        acWidth = innerWidth - 60;
    }
    return {
        width: acWidth
    };
},
handleResize() {
    let innerWidth = window.innerWidth;
    let acWidth;
    if (innerWidth &amp;gt; 991) {
        acWidth = (innerWidth - 144) / 3;
    }
    else {
        acWidth = innerWidth - 60;
    }
    this.setState({
        width: acWidth
    });
},
componentDidMount() {
    window.addEventListener(&#39;resize&#39;, this.handleResize);
},
componentWillUnmount() {
    window.removeEventListener(&#39;resize&#39;, this.handleResize);
},
render() {
    const { width } = this.state;
    let option = {
        // 根据echarts配置项手册配置option
    }
    return &amp;lt;Chart data-source={option} height=&quot;300&quot; width={width}/&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，当浏览器窗口缩放时，所有图都会随着重新渲染。但是出现了又一个问题：&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;判断是否需要重新渲染&lt;/h1&gt;

&lt;p&gt;很多时候的重新渲染都是不必要的，如果开启了echarts的animation，就可以看到，页面中其它组件的状态变化也会使echarts重新渲染一遍。&lt;/p&gt;

&lt;p&gt;此时需要&lt;code class=&quot;highlighter-rouge&quot;&gt;shouldComponentUpdate&lt;/code&gt;来限制重绘：&lt;/p&gt;

&lt;p&gt;Chart组件中添加以下代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shouldComponentUpdate: function(nextProps, nextState) {
    let renderFlag = true;

    if ((this.props.width === nextProps.width)
        &amp;amp;&amp;amp; (JSON.stringify(nextProps[&#39;data-source&#39;]) === JSON.stringify(this.props[&#39;data-source&#39;]))) {
        renderFlag = false;
    }
    return renderFlag;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shouldComponentUpdate&lt;/code&gt;的方法返回false时，不重绘。如此，当宽度和数据都没有变化的时候，图将不会重新渲染；页面上图比较多的时候，这样做非常有必要。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;更多关于React-router&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Apr 2016 14:20:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/echarts/2016/04/19/echarts-react-shouldupdate.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/echarts/2016/04/19/echarts-react-shouldupdate.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
        <category>echarts</category>
        
      </item>
    
      <item>
        <title>react router 2使用</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;React Router keeps your UI in sync with the URL. It has a simple API with powerful features like lazy code loading, dynamic route matching, and location transition handling built right in.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;npm--more--&quot;&gt;使用npm安装&lt;!--more--&gt;&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install --save react-router
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;layout&quot;&gt;在Layout中使用&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;A Layout is something that describes an entire page structure, such as a fixed navigation, viewport, sidebar, and footer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import { Link } from &#39;react-router&#39;

...

const Layout = React.createClass({
    ...
    render: function () {
        return (
            &amp;lt;div className=&quot;wrapper&quot;&amp;gt;
                &amp;lt;PlatformHeader/&amp;gt;
                &amp;lt;PlatformNav/&amp;gt;
                &amp;lt;PlatformContent/&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
});

// this.props.children匹配当前加载的内容
const PlatformContent = React.createClass({
    render: function() {
        return (
            &amp;lt;div className=&#39;main&#39;&amp;gt;
                {this.props.children}
            &amp;lt;/div&amp;gt;
        );
    }
});

// PlatformNav中有url链接（路由需求），例如index
var PlatformNav = React.createClass({
    render: function() {
        return (
            &amp;lt;div className=&#39;nav&#39;&amp;gt;
                ...
                &amp;lt;Link to=&quot;index&quot;&amp;gt;首页&amp;lt;/Link&amp;gt;
                ...
            &amp;lt;/div&amp;gt;
        );
    }
});

...
module.exports = Layout;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;index&quot;&gt;index页&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Index = React.createClass({
    render: function() {
        return (
            &amp;lt;div&amp;gt;
                Welcome!
            &amp;lt;/div&amp;gt;
        );
    }
});

module.exports = Index;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;appjs&quot;&gt;在app.js中配置路由&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Layout = require(&#39;./components/Layout&#39;);
var Index = require(&#39;./components/Index&#39;);

// 引入需要的组件
import { browserHistory, IndexRoute, Router, Route } from &#39;react-router&#39;;

// 设置路由，component是组件名称，path写url
const AppRoute = (
    &amp;lt;Router history={browserHistory}&amp;gt;
            &amp;lt;Route path=&quot;/namespace/&quot; component={Layout}&amp;gt;
                &amp;lt;IndexRoute component={Index}/&amp;gt; 
                &amp;lt;Route path=&#39;index&#39; component={Index}/&amp;gt;
            &amp;lt;/Route&amp;gt;
    &amp;lt;/Router&amp;gt;
);

ReactDOM.render(AppRoute, document.getElementById(&#39;xxx&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;更多关于React-router&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 11 Mar 2016 14:40:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/router/2016/03/11/React-Router-2.0.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/router/2016/03/11/React-Router-2.0.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
        <category>router</category>
        
      </item>
    
      <item>
        <title>react router使用</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;React Router keeps your UI in sync with the URL. It has a simple API with powerful features like lazy code loading, dynamic route matching, and location transition handling built right in.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;npm--more--&quot;&gt;使用npm安装&lt;!--more--&gt;&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install --save react-router
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;layoutroutehandler&quot;&gt;在Layout中使用RouteHandler&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;A Layout is something that describes an entire page structure, such as a fixed navigation, viewport, sidebar, and footer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var React = require(&#39;react&#39;);
var RouteHandler = require(&#39;react-router&#39;).RouteHandler;
var Link = require(&#39;react-router&#39;).Link;

...

var Layout = React.createClass({
    ...
    render: function () {
        return (
            &amp;lt;div className=&quot;wrapper&quot;&amp;gt;
                &amp;lt;PlatformHeader/&amp;gt;
                &amp;lt;PlatformNav/&amp;gt;
                &amp;lt;PlatformContent/&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
});

// RouteHandler是react router的核心组件之一，代表与当前路由（url）匹配的组件。
var PlatformContent = React.createClass({
    render: function() {
        return (
            &amp;lt;div className=&#39;main&#39;&amp;gt;
                &amp;lt;RouteHandler/&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
});

// PlatformNav中有url链接（路由需求），例如index
var PlatformNav = React.createClass({
    render: function() {
        return (
            &amp;lt;div className=&#39;nav&#39;&amp;gt;
                ...
                &amp;lt;Link to=&quot;index&quot;&amp;gt;首页&amp;lt;/Link&amp;gt;
                ...
            &amp;lt;/div&amp;gt;
        );
    }
});

...
module.exports = Layout;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;index&quot;&gt;index页&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Index = React.createClass({
    render: function() {
        return (
            &amp;lt;div&amp;gt;
                Welcome!
            &amp;lt;/div&amp;gt;
        );
    }
});

module.exports = Index;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;appjs&quot;&gt;在app.js中配置路由&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Layout = require(&#39;./components/Layout&#39;);
var Index = require(&#39;./components/Index&#39;);

// 引入需要的组件
var Router = require(&#39;react-router&#39;).Router;
var Route  = require(&#39;react-router&#39;).Route;
var DefaultRoute = require(&#39;react-router&#39;).DefaultRoute; // 默认路由，首页

// 或使用es6
import { Router, Route, DefaultRoute } from &#39;react-router&#39;

// 设置路由，handler中是组件名称，path写url
var routes = (
    &amp;lt;Route&amp;gt;
        &amp;lt;Route path=&quot;/&quot; handler={Layout}&amp;gt;
            &amp;lt;DefaultRoute handler={Index}/&amp;gt;
            &amp;lt;Route path=&#39;index&#39; name=&#39;index&#39; handler={Index}/&amp;gt;
        &amp;lt;/Route&amp;gt;
    &amp;lt;/Route&amp;gt;
);

Router.run(routes, Router.HistoryLocation, (Root) =&amp;gt; {
    React.render(&amp;lt;Root/&amp;gt;, document.body);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，点击nav中的“首页”链接时，浏览器地址栏中会出现’index’，同时页面上能看到“Welcome”。而刷新页面时，也能根据给当前url分配的组件Index，加载想要看到的内容。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;更多关于React-router&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Feb 2016 11:40:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/router/2016/02/19/React-Router.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/router/2016/02/19/React-Router.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
        <category>router</category>
        
      </item>
    
      <item>
        <title>IE9不打开控制台无法正常执行js</title>
        <description>&lt;p&gt;接手一个系统项目，必须运行在windows下，浏览器要求IE9。&lt;/p&gt;

&lt;p&gt;调试脚本的过程中使用过&lt;code class=&quot;highlighter-rouge&quot;&gt;console.log()&lt;/code&gt;，同时页面包含一个&lt;code class=&quot;highlighter-rouge&quot;&gt;setInterval()&lt;/code&gt;方法，每隔300毫秒自动获取接口传过来的数据， 获取到正确的数据之后，停止定时器。&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;chrome中测试无误，然而转到IE9中之后，死活无法等到数据，便想打开控制台看看有没有报错，然而每每一打开控制台几乎瞬间数据就传过来了！试了好多次，确定不是机缘未到，抱着怀疑的心理搜索了一下“ie9 控制台打开才执行js”，果然很多人都遇到过这个问题，但是，故事的结局往往出人意料：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;IE仅在开启developer tools的时候，脚本才能访问到console这个对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这真是一个让人忍不住想吐槽的设定…&lt;/p&gt;

&lt;p&gt;对此情况，解决方案有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;生产环境下移除或者注释掉&lt;code class=&quot;highlighter-rouge&quot;&gt;console.log()&lt;/code&gt; 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为避免报错，这样声明&lt;code class=&quot;highlighter-rouge&quot;&gt;console&lt;/code&gt;：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var console = console || {
      log : function () {
          return;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自定义封装个方法调用：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  function log(msg){
      if (window.console){
          console.log(msg);
      }
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多内容：&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/dn255006(v=vs.85).aspx&quot;&gt;https://msdn.microsoft.com/zh-cn/library/dn255006.aspx&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 25 Jan 2016 17:32:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/ie/js/2016/01/25/ie9%E6%97%A0%E6%B3%95%E5%85%BC%E5%AE%B9console%E5%AF%B9%E8%B1%A1.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/ie/js/2016/01/25/ie9%E6%97%A0%E6%B3%95%E5%85%BC%E5%AE%B9console%E5%AF%B9%E8%B1%A1.html</guid>
        
        
        <category>IE</category>
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>css实现背景图片局部滤镜加半透明效果</title>
        <description>&lt;p&gt;实现效果预览：&lt;a href=&quot;http://www.daipuarchitects.com/?cat=14&quot;&gt;Daipu Architects&lt;/a&gt; 中间区域。&lt;/p&gt;

&lt;p&gt;html：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;wrapper&quot;&amp;gt;
    &amp;lt;div class=&quot;overlay&quot;&amp;gt;
        &amp;lt;div class=&quot;overlay-con&quot;&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;父级div，一般背景图会覆盖浏览器可视区域：&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.wrapper{
    ...
    width: 100%;
    height: 100%;
    background: url(image.png);
    background-size: cover;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;模糊背景层，固定宽度，高度为js计算得出，:after设置模糊效果，如果在child上设置，包含文字也会模糊掉:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.overlay{
    ...
    width: 750px;
    position: absolute;
    bottom: 0;
    left: 50%;
    margin-left: -375px;
    background: inherit;
    ...

    &amp;amp;:after {
        content: &quot;&quot;;
        display: block;
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        background: inherit;
        z-index: 0;
        -webkit-filter: blur(3px);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;文字层div：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.overlay-con {
    background: rgba(255,255,255,.6);
    position: relative;
    z-index: 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;总结：没想到&lt;code class=&quot;highlighter-rouge&quot;&gt;background:inherit&lt;/code&gt;会带来这么大的惊喜～&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Jan 2016 17:21:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/css/2016/01/25/css%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E5%9B%BE%E5%B1%80%E9%83%A8%E6%BB%A4%E9%95%9C%E5%8A%A0%E5%8D%8A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/css/2016/01/25/css%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E5%9B%BE%E5%B1%80%E9%83%A8%E6%BB%A4%E9%95%9C%E5%8A%A0%E5%8D%8A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C.html</guid>
        
        
        <category>css</category>
        
      </item>
    
      <item>
        <title>forever守护进程相关记录</title>
        <description>&lt;h2 id=&quot;forever&quot;&gt;安装forever&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install forever -g
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;forever-1&quot;&gt;使用forever&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;用法一：&lt;/h3&gt;

&lt;p&gt;例如：后台定时运行一个phantomjs截图的任务。&lt;/p&gt;

&lt;p&gt;phantmjs截图的代码写在pagename.js中：
&lt;!--more--&gt;
    var page = require(‘webpage’).create();&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;page.open(&#39;pageurl&#39;, function() {
    page.render(&#39;imagePath&#39;);
    phantom.exit();
});
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;定时任务写在capturePage.js中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var childProcess = require(&#39;child_process&#39;);

getImageDaily();

function getImageDaily() {
    getImageByDate(date, function () {
        // 一小时后再更新
        setTimeout(function () {
            getImageDaily();
        }, 60*60000);
    }, function (error, stdout) {
        ...
    });
}

getImageByDate(date) {
    childProcess.exec(&#39;phantomjs pagename.js&#39;, function (error, stdout, stderr) {
        ...
    });
}

app.listen(port || 8888);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;$ forever start capturePage.js&lt;/code&gt;后，查看node进程：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ps aux|grep node

xxx           13169   0.0  0.4  3058580  33252   ??  S     5:02PM   0:00.22 /usr/local/bin/node /Users/baidu/Documents/xxx/capturePage.js
xxx           13168   0.0  0.5  3057732  39420   ??  Ss    5:02PM   0:00.37 /usr/local/bin/node /usr/local/lib/node_modules/forever/bin/monitor capturePage.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;多出了一个monitor的进程，然后，杀死13169即capturePage.js的进程：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kill 13169
$ ps aux|grep node

xxx           13176   0.0  0.4  3058580  33144   ??  S     5:05PM   0:00.22 /usr/local/bin/node /Users/baidu/Documents/xxx/capturePage.js
xxx           13168   0.0  0.5  3057732  39740   ??  Ss    5:02PM   0:00.38 /usr/local/bin/node /usr/local/lib/node_modules/forever/bin/monitor capturePage.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，杀死capturePage.js之后，capturePage.js重启了，进程号不同了。&lt;/p&gt;

&lt;h3 id=&quot;forever-monitorcapturepagejs&quot;&gt;用法二：安装forever-monitor，编码式监控capturePage.js&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install forever-monitor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;新建文档monitor.js：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var forever = require(&#39;forever-monitor&#39;);

var child = new (forever.Monitor)(&#39;capturePage.js&#39;, {
    max: 3,
    silent: true,
    args: []
});

child.on(&#39;exit&#39;, function () {
    console.log(&#39;your-filename.js has exited after 3 restarts&#39;);
});

child.start();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;后台执行monitor.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ node monitor.js &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;优点是，自主可控，缺点是，自己写的，功能不会很完善，当然比不上forever命令，还有日志管理等等。&lt;/p&gt;

&lt;p&gt;资料参考：&lt;a href=&quot;https://github.com/foreverjs/forever-monitor&quot;&gt;forever-monitor&lt;/a&gt;、&lt;a href=&quot;https://github.com/foreverjs/forever&quot;&gt;forever&lt;/a&gt;、&lt;a href=&quot;http://phantomjs.org/screen-capture.html&quot;&gt;phantomjs&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Jan 2016 16:35:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/node/forever/phantomjs/2016/01/25/forever%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/node/forever/phantomjs/2016/01/25/forever%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95.html</guid>
        
        
        <category>node</category>
        
        <category>forever</category>
        
        <category>phantomjs</category>
        
      </item>
    
      <item>
        <title>gulp打包编译速度优化</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;保持对新技术的好奇心，深入研究当前工作使用的技术，同时进行一些输出，例如写博客，做开源，研究分享，写书等的，没有输出的学习就是耍流氓。
——来自知乎&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;做项目时使用了browserify，但每次修改编译时间都很长，十几秒的样子？&lt;!--more--&gt;反正感觉等待编译的时间已经远远超过了修改代码的时间，忍无可忍之时，开始寻找解决方案。&lt;/p&gt;

&lt;p&gt;于是很快就找到了watchify，简单理解，就是增量编译。&lt;/p&gt;

&lt;p&gt;修改之前：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var source = require(&#39;vinyl-source-stream&#39;);
var browserify = require(&#39;browserify&#39;);
var streamify = require(&#39;gulp-streamify&#39;);

gulp.task(&#39;browserify&#39;, function () {
    var bundleStream = browserify(&#39;v1/js/app.js&#39;).bundle();

    return bundleStream
    .pipe(source(&#39;app.js&#39;))
    .pipe(streamify(uglify()))
    .pipe(gulp.dest(&#39;./dev/js/&#39;));
});

// after each change, execute browserify, make a long long progress...
gulp.task(&#39;release&#39;, [&#39;browserify&#39;], function () {
    return gulp.src(&#39;./dev/js/app.js&#39;)
    .pipe(gulp.dest(&#39;../static/js/&#39;));
});

// watch everything
gulp.task(&#39;watch&#39;, function () {
    gulp.watch([&#39;v1/less/**/*&#39;], [&#39;css2js&#39;]);
    gulp.watch([&#39;v1/js/**/*&#39;], [&#39;release&#39;]);
});

...
gulp.task(&#39;default&#39;, [&#39;release&#39;, &#39;watch&#39;]);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;添加watchify：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var watchify = require(&#39;watchify&#39;); 
var source = require(&#39;vinyl-source-stream&#39;);
var browserify = require(&#39;browserify&#39;);
var streamify = require(&#39;gulp-streamify&#39;);
var assign = require(&#39;lodash.assign&#39;);

var bundleStream = watchify(browserify(assign({}, watchify.args, {
    // required for watchify
    cache: {},
    // required for watchify
    packageCache: {},
    entries: [&#39;v1/js/app.js&#39;]
}))); 

gulp.task(&#39;browserify&#39;, bundle);
// on any dep update, runs the bundler
bundleStream.on(&#39;update&#39;, bundle);
// output build logs to terminal
bundleStream.on(&#39;log&#39;, gutil.log);

function bundle() {  
  return bundleStream.bundle()
    // log errors if they happen
    .on(&#39;error&#39;, gutil.log.bind(gutil, &#39;Browserify Error&#39;))
    .pipe(source(&#39;app.js&#39;))
    .pipe(streamify(uglify()))
    .pipe(gulp.dest(&#39;./dev/js/&#39;));
}

// browserify will not need
gulp.task(&#39;release&#39;, function () {
    return gulp.src(&#39;./dev/js/app.js&#39;)
    .pipe(gulp.dest(&#39;../static/js/&#39;));
});

gulp.task(&#39;watch&#39;, function () {
    gulp.watch([&#39;v1/less/**/*&#39;], [&#39;css2js&#39;]);
    // just watch one file produced by WATCHIFY
    gulp.watch([&#39;./dev/js/app.js&#39;], [&#39;release&#39;]);
});

...
// only at the beginning browserify being executed
gulp.task(&#39;default&#39;, [&#39;browserify&#39;, &#39;watch&#39;]);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;延伸阅读及参考资料：&lt;/p&gt;

&lt;p&gt;http://csspod.com/advanced-tips-for-using-gulp-js/&lt;/p&gt;

&lt;p&gt;http://csspod.com/using-browserify-with-gulp/&lt;/p&gt;
</description>
        <pubDate>Mon, 21 Dec 2015 11:28:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/gulp/browserity/2015/12/21/gulp%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/gulp/browserity/2015/12/21/gulp%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96.html</guid>
        
        
        <category>gulp</category>
        
        <category>browserity</category>
        
      </item>
    
      <item>
        <title>flux中使用react-loder</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;做一个react的项目，需要loading菊花的效果，找到了&lt;a href=&quot;https://github.com/quickleft/react-loader&quot;&gt;react-loader&lt;/a&gt;，然而README中只有一些不明觉厉的伪代码…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;经过多番尝试，终于做出来了一款flux的小菊花…三木君说，这种方法藕合度挺高的。然而我目前想不到更好（kuai，四声）&lt;!--more--&gt;的方法来对付手头的flux项目了…如果谁有思路，请&lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#104;&amp;#097;&amp;#110;&amp;#099;&amp;#111;&amp;#110;&amp;#103;&amp;#057;&amp;#049;&amp;#048;&amp;#052;&amp;#064;&amp;#049;&amp;#054;&amp;#051;&amp;#046;&amp;#099;&amp;#111;&amp;#109;&quot;&gt;务必告知&lt;/a&gt;，不胜感激。&lt;/p&gt;

&lt;p&gt;In the view:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;Loader loaded={!this.state.data.isLoading} ... /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;When send a xhr request:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
componentDidMount: function () {
    sampleStore.addChangeListener(this._change);

    if (this.isMounted()) {
        // 发请求之前都先setIsLoading
        SampleActions.setIsLoading();
        SampleActions.loadData(); 
    }
},
..
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And in SampleActions.js:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
setIsLoading: function (params) {
    PlatformDispatcher.dispatch({
        actionType: &#39;order_statistic_set_isLoading&#39;,
        item: params
    });
},
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then, in sampleStore.js:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PlatformDispatcher.register(function (payload) {
    var actionType = payload.actionType;

    switch (actionType) {
        ...
        case &#39;order_statistic_set_isLoading&#39;:
          orderStatisticStore.setIsLoading(payload.item);
          break;
        ...
    }
});

OrderStatisticStore.prototype = assign({}, EventEmitter.prototype, {
    setIsLoading: function (params) {
        // when send a xhr request, change state
        this.data.isLoading = true;
        this.emit(&#39;change&#39;);
    },
    loadData: function (params, callback) {
        var params = params || {};

        // send request
        PlatformRequest.getQuestHandle({
            url: ...,
            data: {
                ...
            }
        }, function (res) {
            // when success, change the state of isLoading
            this.data.isLoading = false;
            this.data... = res;
            this.emitChange();
            callback &amp;amp;&amp;amp; callback();
        }.bind(this));
    },
    ...
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果再配合bootstrap-react的loading button state，也是美呆了…&lt;/p&gt;
</description>
        <pubDate>Thu, 24 Sep 2015 15:07:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/loader/2015/09/24/react-loader-with-flux.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/loader/2015/09/24/react-loader-with-flux.html</guid>
        
        
        <category>react</category>
        
        <category>loader</category>
        
      </item>
    
      <item>
        <title>用react完成一个带省略号的分页</title>
        <description>&lt;p&gt;分页其实想起来很容易：不过就是从后台拿一些数据来——当前页码、总页数、总条目数、每页显示的数量等等。&lt;/p&gt;

&lt;p&gt;本篇将完成一个具备以下简单功能的react组件（结合Flux）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;页码list&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;首页、末页、上下页&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;页码数量过多时用省略号指引&lt;!--more--&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section&quot;&gt;组件将被这样使用：&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;Pagination currentPn={currentPn}
        pageCount={pageCount}
        pageSize={pageSize}
        dataSize={dataSize}
        clickHandler={this.changePn}
        prevHandler={this.prevPn}
        nextHandler={this.nextPn}
        firstHandler={this.firstPn}
        lastHandler={this.lastPn}
&amp;gt;
&amp;lt;/Pagination&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;点击每一个list中的页码链接，执行&lt;code class=&quot;highlighter-rouge&quot;&gt;this.changePn&lt;/code&gt;方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;changePn: function (e) {
    e.preventDefault();
    ExampleActions.setPageNumber({
        pageNumber: e.target.innerHTML
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上下页翻页方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;prevPn: function (e) {
    e.preventDefault();
    ExampleActions.setPageNumber({
        pageNumber: currentPn － 1
    });
},
nextPn: function (e, currentPn) {
    e.preventDefault();
    ExampleActions.setPageNumber({
        pageNumber: currentPn ＋ 1
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首页和末页方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;firstPn: function (e) {
    e.preventDefault();
    ExampleActions.setPageNumber({
        pageNumber: 1
    });
},
lastPn: function (e, currentPn) {
    e.preventDefault();
    ExampleActions.setPageNumber({
        pageNumber: pageCount
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述五个方法执行后，通过action调用dispatcher，dispatcher调用store，store中loadData，重新render组件这个过程更新页面中展示的数据。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;组件将被这样实现：&lt;/h1&gt;

&lt;p&gt;定义变量：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var pageList = &#39;&#39;;
var pageListArr = [];
var prevPage = &#39;&#39;;
var nextPage = &#39;&#39;;
var firstPage = &#39;&#39;;
var lastPage = &#39;&#39;;
var thisProps = this.props;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;展示页码list并不难，取到上面使用组件时传递过来的属性，将pageCount肢解，遍历，加入标签组装就可以完成这个任务：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (var i = 0; i &amp;lt; thisProps.pageCount; i++) {
    pageListArr.push(i);
};
pageList = pageListArr.map(function (item) {
    // 判断是否当前页
    if (item === thisProps.currentPn) {
        return (
            &amp;lt;li className=&quot;active&quot;&amp;gt;&amp;lt;a href=&quot;&quot; onClick={thisProps.clickHandler}&amp;gt;
                {item}&amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
    else {
        return (
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;&quot; onClick={thisProps.clickHandler}&amp;gt;
                {item}&amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上下页翻页链接，要判断是否可点击，首页和末页类似，但不需要判断状态：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 上一页
prevPage = (function () {
    if (thisProps.currentPn === 1) {
        return (
            &amp;lt;li className=&quot;disabled&quot;&amp;gt;
              &amp;lt;span&amp;gt;
                &amp;lt;span aria-hidden=&quot;true&quot;&amp;gt;上一页&amp;lt;/span&amp;gt;
              &amp;lt;/span&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
    else {
        return (
            &amp;lt;li&amp;gt;
              &amp;lt;a href=&quot;#&quot; aria-label=&quot;Previous&quot; onClick={thisProps.prevHandler}&amp;gt;
                &amp;lt;span aria-hidden=&quot;true&quot;&amp;gt;上一页&amp;lt;/span&amp;gt;
              &amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
})();

// 下一页
nextPage = (function () {
    if (thisProps.currentPn === thisProps.pageCount) {
        return (
            &amp;lt;li className=&quot;disabled&quot;&amp;gt;
              &amp;lt;span&amp;gt;
                &amp;lt;span aria-hidden=&quot;true&quot;&amp;gt;下一页&amp;lt;/span&amp;gt;
              &amp;lt;/span&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
    else {
        return (
            &amp;lt;li&amp;gt;
              &amp;lt;a href=&quot;#&quot; aria-label=&quot;Next&quot; onClick={thisProps.nextHandler}&amp;gt;
                &amp;lt;span aria-hidden=&quot;true&quot;&amp;gt;下一页&amp;lt;/span&amp;gt;
              &amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
})();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;组装：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ul className=&quot;pagination pull-right&quot;&amp;gt;
    {firstPage}
    {prevPage}
    {pageList}
    {nextPage}
    {lastPage}
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;section-2&quot;&gt;显示省略号&lt;/h1&gt;

&lt;p&gt;考虑四种情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;左边右边都不需要省略号&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;左边有省略号，右边没有&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;左边没有省略号，右边有&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;左右两边都需要省略号&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;再考虑：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“首页”和“末页”可以用“1”“100（假设是最后一页的页码）”放在list中代替，因为不管有没有省略号，1和100始终都要显示出来。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两种实现思路：&lt;/p&gt;

&lt;p&gt;1、四种不同的情况下，直接拼装包含&lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt;的html代码&lt;/p&gt;

&lt;p&gt;2、四种不同的情况下，先拼装pageListArr这个变量，再遍历生成html代码&lt;/p&gt;

&lt;p&gt;考虑到react中store影响view这个特性，我决定采用第二种方法（我不会告诉你其实我先尝试了第一种方法，然后拼装变量和字符串快要崩溃…jsx都不完全懂，还是默默地去操作变量吧…何况这样真的比较清爽…）&lt;/p&gt;

&lt;p&gt;添加变量：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 假设当前页码总在中间显示，pageTab就是当前页码到省略号之间的数量，比如1...4,5,6,7,8...100，pageTab就是2
var pageTab = 4;

// 左边的省略号，在第1页之后
var leftEllipse = &#39;&#39;;

// 右边的省略号，在第100页之前
var rightEllipse = &#39;&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;总页数小于11，全部显示（这里可以做成可配置的）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (thisProps.pageCount &amp;lt; 11) {

    // 注意pageListArr要先清空
    pageListArr = [];

    // 从第二页开始显示，到倒数第二页
    for (var i = 1; i &amp;lt; thisProps.pageCount-1; i++) {
        pageListArr.push(i);
    };

    //左右都没有省略号
    leftEllipse = &#39;&#39;;
    rightEllipse = &#39;&#39;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;总页码数大于11时，有&lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt;出现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (thisProps.pageCount &amp;gt; 10) {
    // 当前页减去pageTab小于1，右边显示省略号，左边不显示
    if (thisProps.currentPn - pageTab &amp;lt; 1) {

        pageListArr = [];

        for (var i = 1; i &amp;lt; 10; i++) {
            pageListArr.push(i);
        };

        leftEllipse = &#39;&#39;;
        rightEllipse = &amp;lt;li&amp;gt;&amp;lt;span&amp;gt;...&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;;
    }

    // 当前页减去pageTab大于1 且 当前页加上pageTab小于总页数，两边都显示省略号
    if ((thisProps.currentPn - pageTab &amp;gt; 1) &amp;amp;&amp;amp; ((thisProps.currentPn + pageTab) &amp;lt; thisProps.pageCount)) {

        pageListArr = [];

        for (var i = thisProps.currentPn - pageTab; i &amp;lt; thisProps.currentPn + pageTab; i++) {
            pageListArr.push(i);
        };

        leftEllipse = &amp;lt;li&amp;gt;&amp;lt;span&amp;gt;...&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;;
        rightEllipse = &amp;lt;li&amp;gt;&amp;lt;span&amp;gt;...&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;
    }

    // 当前页码加上pageTab大于总页数，右边不显示省略号，左边显示
    if ((thisProps.currentPn + pageTab) &amp;gt; (thisProps.pageCount)) {

        pageListArr = [];

        for (var i = thisProps.pageCount - (pageTab*2 + 1); i &amp;lt; thisProps.pageCount; i++) {
            pageListArr.push(i);
        };

        leftEllipse = &amp;lt;li&amp;gt;&amp;lt;span&amp;gt;...&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;;
        rightEllipse = &#39;&#39;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首页和末页：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 首页
firstPage = (function () {
    if (thisProps.currentPn === 1) {
        return (
            &amp;lt;li className=&quot;active&quot;&amp;gt;&amp;lt;a href=&quot;&quot; onClick={thisProps.firstHandler}&amp;gt;
                1&amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
    else {
        return (
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;&quot; onClick={thisProps.firstHandler}&amp;gt;
                1&amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
})();

// 末页
lastPage = (function () {
    if (thisProps.currentPn === thisProps.pageCount) {
        return (
            &amp;lt;li className=&quot;active&quot;&amp;gt;&amp;lt;a href=&quot;&quot; onClick={thisProps.lastHandler}&amp;gt;
                {thisProps.pageCount}&amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
    else {
        return (
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;&quot; onClick={thisProps.lastHandler}&amp;gt;
                {thisProps.pageCount}&amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
})();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;装入&lt;code class=&quot;highlighter-rouge&quot;&gt;ul&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ul className=&quot;pagination pull-right&quot;&amp;gt;
    {prevPage}
    {firstPage}
    {leftEllipse}
    {pageList}
    {rightEllipse}
    {lastPage}
    {nextPage}
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;总的组织结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Pagination = React.createClass({
    render: function () {
        ...算法／过程...
        return (
            &amp;lt;ul&amp;gt;
                ...组装结果...
            &amp;lt;/ul&amp;gt;
        );
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外，传递过来的dataSize、pageSize还可以展示出来，写一个总结：本页共有xx条数据，等等..&lt;/p&gt;

&lt;p&gt;pageSize也可以做成select形式的，用户可以调整每页展示的数量…&lt;/p&gt;

&lt;p&gt;备注：分页样式使用bootstrap。&lt;/p&gt;
</description>
        <pubDate>Mon, 07 Sep 2015 19:18:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/2015/09/07/js-react-pagination.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/2015/09/07/js-react-pagination.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>react ajax跨域请求</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;同源策略&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy&quot;&gt;同源策略&lt;/a&gt;限制了一个源（origin）中加载文本或脚本与来自其它源（origin）中资源的交互方式。如果两个页面拥有相同的 &lt;code class=&quot;highlighter-rouge&quot;&gt;协议（protocol）&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;端口&lt;/code&gt;（如果指定），和 &lt;code class=&quot;highlighter-rouge&quot;&gt;主机&lt;/code&gt;，那么这两个页面就属于同一个源（origin）。&lt;!--more--&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在使用XMLHttpRequest时会受到同源策略的约束。&lt;/p&gt;

&lt;p&gt;浏览器发送的请求header中包含一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Origin&lt;/code&gt;，而服务器返回给浏览器的响应header中包含一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Access-Control-Allow-Origin&lt;/code&gt;，因此：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;可以通过设置&lt;code class=&quot;highlighter-rouge&quot;&gt;Access-Control-Allow-Origin:&lt;/code&gt;来允许跨域请求，origin的值可以设置为｀*｀，表示接受来自任何站点的跨域请求，也可以设置为特定的域，表示只有这个域能跨域请求到服务器上的数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot;&gt;cors(Cross-Origin Resource Sharing)&lt;/a&gt;可以实现跨域访问，但cors只支持现代浏览器。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;jsonp&quot;&gt;jsonp&lt;/h1&gt;

&lt;p&gt;jsonp（json with padding），一种包含在函数调用中的json。解决跨域请求比较可靠的一种思路是：设置&lt;code class=&quot;highlighter-rouge&quot;&gt;dataType&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;jsonp&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;普通的json格式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;name&#39;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&#39;insekkei&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;jsonp格式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;callback(
    {&#39;name&#39;: &#39;insekkei&#39;}
);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;即：调用jsonp回调函数callback，并将返回的json作为参数传入这个回调函数。&lt;code class=&quot;highlighter-rouge&quot;&gt;callback&lt;/code&gt;是jsonp请求默认的回调函数名称，会在请求url中追加&lt;code class=&quot;highlighter-rouge&quot;&gt;?callback=?&lt;/code&gt;，也可以自定义这个名称：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dataType : &#39;jsonp&#39;,
jsonp: &#39;callbackName&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这时服务器需要返回的数据格式为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;callbackName(
    {&#39;name&#39;: &#39;insekkei&#39;}
);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;显而易见，jsonp不仅需要客户端js进行配置，也需要服务器端返回数据格式的配合。不过，&lt;code class=&quot;highlighter-rouge&quot;&gt;jsonp只支持get请求...&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&quot;superagent&quot;&gt;superagent&lt;/h1&gt;

&lt;p&gt;react中需要ajax请求时，可以使用&lt;a href=&quot;https://cnodejs.org/topic/5378720ed6e2d16149fa16bd&quot;&gt;superagent&lt;/a&gt;这个模块，例如一个get请求：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var request = require(&#39;superagent&#39;);

request
    .get(url)
    .set(&#39;Accept&#39;, &#39;application/json&#39;)
    .query(paramObj)
    .end(function(res){
        // do something
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;post方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;request
    .post(url)
    .send(dataObj)
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然而有时候需要跨域请求数据，如果只是使用上面的方法，控制台会出现类似如下提示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;XMLHttpRequest cannot load http://xxx.xx.... No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;http://yyy.yy...&#39; is therefore not allowed access.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;superagent-jsonp&quot;&gt;superagent-jsonp&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/superagent-jsonp&quot;&gt;superagent-jsonp&lt;/a&gt;为superagent添加了jsonp方法。&lt;/p&gt;

&lt;p&gt;安装：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i superagent-jsonp --save
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var request = require(&#39;superagent&#39;);
var superagent = require(&#39;superagent&#39;);
require(&#39;superagent-jsonp&#39;)(request);

request
    .get(url)
    .jsonp()
    .end(function(){
        // do something...
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 02 Sep 2015 10:10:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/ajax/2015/09/02/js-react%E8%B7%A8%E5%9F%9F.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/ajax/2015/09/02/js-react%E8%B7%A8%E5%9F%9F.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
        <category>ajax</category>
        
      </item>
    
  </channel>
</rss>
