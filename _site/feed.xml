<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>web前端笔记</title>
    <description>绿螘新醅酒，红泥小火炉。&lt;br&gt;晚来天欲雪，能饮一杯无？
</description>
    <link>http://insekkei.com/blogs//blogs/</link>
    <atom:link href="http://insekkei.com/blogs//blogs/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 15 Aug 2016 15:44:27 +0800</pubDate>
    <lastBuildDate>Mon, 15 Aug 2016 15:44:27 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>js中的Date另类使用</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;如何获得某个月的天数？&lt;/h2&gt;

&lt;p&gt;方法一&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const EVERY_MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

function getDays(year, month) {
    if (month === 1 &amp;amp;&amp;amp; isLeap(year)) return 29;
    return EVERY_MONTH_DAYS[month];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;!--more--&gt;
&lt;p&gt;方法二&lt;/p&gt;

&lt;p&gt;我们发现，new Date()的第三个参数是可以大于我们所知的每个月的最后一天的的，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new Date(2016, 0, 200) //Mon Jul 18 2016 00:00:00 GMT+0800 (CST)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;于是&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getDays(year, month) {
    if (month === 1) return new Date(year, month, 29).getMonth() === 1 ? 29 : 28;
    return new Date(year, month, 31).getMonth() === month ? 31 : 30;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;方法三&lt;/p&gt;

&lt;p&gt;new Date()的第三个参数传小于1的值会怎么样了，比如传0，我们就获得了上个月的最后一天。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new Date(2016, 0, -200) //Sun Jun 14 2015 00:00:00 GMT+0800 (CST)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;于是&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getDays(year, month) {
    return new Date(year, month + 1, 0).getDate();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;javascript--y-m-d-his-&quot;&gt;JavaScript 显示 Y-m-d H:i:s 的日期时间格式&lt;/h2&gt;

&lt;p&gt;方法一&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let date = new Date();
let result = [
    [
        date.getFullYear(),
        date.getMonth() + 1,
        date.getDate()
    ].join(&#39;-&#39;),
    [
        date.getHours(),
        date.getMinutes(),
        date.getSeconds()
    ].join(&#39;:&#39;)
].join(&#39; &#39;).replace(/\b\d\b/g, &#39;0$&amp;amp;&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;方法二&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new Date().toLocaleString(&#39;zh-CN&#39;, { hour12: false }) // &quot;2016/8/15 15:41:44&quot;
new Date().toLocaleString(&#39;zh-CN&#39;, { hour12: true }) // &quot;2016/8/15 下午3:42:06&quot;

var date = new Date();
var result = date.toLocaleString(&#39;zh-CN&#39;, { hour12: false })
    .replace(/\//g, &#39;-&#39;).replace(/\b\d\b/g, &#39;0$&amp;amp;&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 28 Jul 2016 14:02:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/js/date/2016/07/28/date-others.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/js/date/2016/07/28/date-others.html</guid>
        
        
        <category>js</category>
        
        <category>Date</category>
        
      </item>
    
      <item>
        <title>nodejs中使用socket完成长连接</title>
        <description>
</description>
        <pubDate>Wed, 08 Jun 2016 10:37:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/nodejs/socket/2016/06/08/nodejs-socket.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/nodejs/socket/2016/06/08/nodejs-socket.html</guid>
        
        
        <category>nodejs</category>
        
        <category>socket</category>
        
      </item>
    
      <item>
        <title>react和css实现一个高度自适应的textarea</title>
        <description>&lt;p&gt;textarea默认有滚动条，设置height: auto或者固定高度的话，书写体验又不够好；若使用div，设置contentEditable为true，兼容起来比较麻烦，而且这家伙复制粘贴时带着源格式，不好操作。
所以还是想办法使用textarea吧。&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;考虑文字换行等情况，这里使用 &amp;lt;pre&amp;gt; 符号，将textarea的值同步到 &amp;lt;pre&amp;gt; 中，通过这个看不见的 &amp;lt;pre&amp;gt; 盒子的高度自增长，撑高 autoHeight ，然后设置textarea绝对定位，top为0，覆盖&amp;lt;pre&amp;gt;的位置，且高度撑满 autoHeight （100%）。&lt;/p&gt;

&lt;p&gt;js:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
getInitialState() {
    return {
        text: &#39;react和css实现一个高度自适应的textarea&#39;
    }
},
changeText(e) {
    this.setState({
        text: e.target.value
    });
},
render() {
    return &amp;lt;div className=&quot;autoHeight&quot;&amp;gt;
        &amp;lt;pre&amp;gt;{this.state.text}&amp;lt;/pre&amp;gt;
        &amp;lt;textarea onChange={this.changeText}&amp;gt;&amp;lt;/textarea&amp;gt;
    &amp;lt;/div&amp;gt;;
}
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;css:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.autoHeight {
    position: relative;

    pre{
        display: block;
        visibility: hidden;
        min-height: 10em;
        padding: 6px 7px; /*需要与textarea保持一致*/
        white-space: pre-wrap;
        line-height: 1.7em;
    }

    textarea {
        resize: none;
        position: absolute;
        height: 100%;
        top: 0;
        line-height: 1.7em;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;理论上，这样就可以实现目的了，但总有点瑕疵——pre和textarea的高度并非完全相等，于是，我将pre的visibility和textarea的top注释掉，对比两个在页面上的表现，发现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pre 每段话是不换行的，横向一撑到底，相当于设置了white-space: no-wrap；&lt;/li&gt;
  &lt;li&gt;pre 每一段（即textarea中的return换行）的段落间距比较大（其实是line-height）；&lt;/li&gt;
  &lt;li&gt;textarea 有预置的padding&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是改成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pre{
    display: block;
    visibility: hidden;
    min-height: 10em;
    padding: 6px 7px; /*需要与textarea保持一致*/
    white-space: pre-wrap; /*按照textarea中的内容，该换行换行*/
    line-height: 1.7em; /*需要与textarea保持一致*/
}

textarea {
    resize: none;
    position: absolute;
    height: 100%;
    top: 0;
    line-height: 1.7em;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;完美。&lt;/p&gt;

&lt;p&gt;于是再一次打开lofter准备写点儿什么时，顺手审查了一下编辑框：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;body contenteditable=&quot;true&quot; spellcheck=&quot;false&quot; style=&quot;min-height: 170px;&quot;&amp;gt;&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;难怪全屏写文章时光标经常就失踪了 (;´༎ຶД༎ຶ`) …&lt;/p&gt;

</description>
        <pubDate>Mon, 06 Jun 2016 15:21:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/js/react/css/2016/06/06/css-textarea-autoheight.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/js/react/css/2016/06/06/css-textarea-autoheight.html</guid>
        
        
        <category>js</category>
        
        <category>react</category>
        
        <category>css</category>
        
      </item>
    
      <item>
        <title>一个copy对象的诡异😂问题</title>
        <description>&lt;p&gt;遇到一个诡异的问题，简单写成代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; var o = [{a: 1}, {a: 2}, {a: 3}]; var o2 = o; var o3 = o; o2.splice(0, 1); o3;
&amp;lt; [Object, Object]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;真实的数据结构比这个复杂一些…&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;copy出o3的本意是，保存一个副本以便与o2经过各种操作后进行比较。然而每次遍历取o3里值组成一个简单数组时，总会发现，o3跟着o2动了…&lt;/p&gt;

&lt;p&gt;too young too simple的我以为这是灵异事件…而忘了“世界上没有无缘无故的bug”这句话（嗯，这句话也是我总结出来的…）。&lt;/p&gt;

&lt;p&gt;于是，我把代码逻辑改成了如下形式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; var o = [{a: 1}, {a: 2}, {a: 3}]; var o2 = o; var o3 = o.map(item =&amp;gt; item.a); o2.splice(0,1); o3;
&amp;lt; [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;直接保存成一个目标数组了…&lt;/p&gt;

&lt;p&gt;问题虽然解决了，可是为什么o3会跟着o2动呢？&lt;/p&gt;

&lt;p&gt;有一天组里的小伙伴抛了一个问题在群里：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var o = { 
    a: {
        b: 2
    }
}; 
var o2 = o;
o = 1;
问：o2是什么？
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我根据上次的经验，想也不想，回答：1&lt;/p&gt;

&lt;p&gt;然而在控制台试了下，是 Object {a: Object}…&lt;/p&gt;

&lt;p&gt;看了其他小伙伴的回复，再查了下，原来，&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; 操作符中，对象和数组是引用，字符串数字才是副本…也就是说，o2，o3指向的是同一个地址，只是名字不一样而已…&lt;/p&gt;

&lt;p&gt;我又恍惚地记起了一些面试题，slice复制数组什么的…object.assign什么的…&lt;/p&gt;

&lt;p&gt;看来实践需要配合理论啊…&lt;/p&gt;
</description>
        <pubDate>Mon, 30 May 2016 16:05:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/js/object/2016/05/30/js-copy-object.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/js/object/2016/05/30/js-copy-object.html</guid>
        
        
        <category>js</category>
        
        <category>object</category>
        
      </item>
    
      <item>
        <title>nodejs中使用mongodb</title>
        <description>&lt;p&gt;需求背景：线上出问题时可以找出近期数据相关的操作历史，但日志只在内网访问。&lt;/p&gt;

&lt;p&gt;于是可以把日志相关的数据保存在mongodb中。&lt;/p&gt;

&lt;p&gt;yog2的框架中，后端文件结构如下：&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server | - action/api/xx.es
         - lib/dataFetch.es..
         - model | - schema/appfilterlog.es
                   - appfilterlog.es
         - config.es
         - router.es
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先定义表结构，model/schema/appfilterlog.es中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&#39;use strict&#39;;

import * as mongoose from &#39;mongoose&#39;;
let logSchema = mongoose.Schema({
    time: Date,
    operate: String,
    operator: String,
    requestData: String
});

let appfilterlog = mongoose.model(&#39;appfilterlog&#39;, logSchema, &#39;Appfilterlog&#39;);

export default appfilterlog;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;存储数据的方法，在model/appfilterlog.es中，需要保存时间、操作（增加／删除／修改）、操作人、请求数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&#39;use strict&#39;;

import appfilterlog from &#39;./schema/appfilterlog&#39;;

export  async function newLog (operate, operator, requestData) {
    appfilterlog.create({
        time: new Date(),
        operate: operate,
        operator: operator,
        requestData: requestData
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在action中调用增加／删除／修改的参数时，也调用newLog的方法，例如action/api/add.es中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import {newLog} from &#39;../../../../../../model/appfilterlog&#39;;
...
newLog(&#39;add&#39;, user.email, JSON.stringify(req.query));
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Thu, 26 May 2016 16:37:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/nodejs/mongo/2016/05/26/mongoose-with-nodejs.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/nodejs/mongo/2016/05/26/mongoose-with-nodejs.html</guid>
        
        
        <category>nodejs</category>
        
        <category>mongo</category>
        
      </item>
    
      <item>
        <title>使用css完成一个三维立体旋转相册</title>
        <description>&lt;p&gt;本篇主要通过这个实践练习transform及3D旋转。&lt;/p&gt;

&lt;p&gt;浏览器中，3D旋转时，主要看x轴、y轴、z轴的方向，旋转所绕的轴是一条横线，为x轴旋转，竖线，为y轴旋转，x和y轴都在显示器所在的平面上。z轴则垂直显示器所在的平面。&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;说到3D，必须提到的一个词：透视，也就是perspective，perspective属性定义3D元素距视图的距离，以像素计，定义观察者在z轴上与3D元素的距离（沿着z轴，与浏览器所在面垂直着，向前走，向后走…，越向前，值越小，越“靠近”3D元素，靠近到0时，看不见了！此刻元素在你脑后！越“远离”，值越大，大到一定程度时，也看不见了！此刻元素已经化身为一个点了…），与之配合的一个属性叫做perspective-origin，两个值，分别定义视角在x轴偏离的角度（从左边向右👉看？从正前方看？从右边向左👈看？）和在y轴偏离的角度（从上边👇俯视？从正前方看？从下边👆仰视？）。&lt;/p&gt;

&lt;p&gt;html代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;stage&quot;&amp;gt;
    &amp;lt;div class=&quot;wrapper&quot;&amp;gt;
        &amp;lt;img src=&quot;http://ww1.sinaimg.cn/large/854f1e58jw1exjhap4pg2j21jk1jku0x.jpg&quot;/&amp;gt;
        &amp;lt;img src=&quot;http://ww3.sinaimg.cn/thumb180/854f1e58jw1f3adtzqrgvj21j01j0x26.jpg&quot;/&amp;gt;
        &amp;lt;img src=&quot;http://tupian.aladd.net/2015/7/2748.jpg&quot;/&amp;gt;
        &amp;lt;img src=&quot;http://ww3.sinaimg.cn/bmiddle/89f08a15gw1f3nc7unjq4j20k00k0dhd.jpg&quot;/&amp;gt;
        &amp;lt;img src=&quot;http://tpic.home.news.cn/xhCloudNewsPic/xhpic1501/M04/0D/54/wKhTlFcr1i-EX9ZYAAAAAG2hseo834.jpg&quot;/&amp;gt;
        &amp;lt;img src=&quot;https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcT7Mf-EWjUIFy77lI2zj2bOyTEcF78SS_AYMo6PfFWzYDQsa_9HEg&quot;/&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;stage是整个3D旋转相册的舞台，wrapper是一组相册的包装元素。&lt;/p&gt;

&lt;p&gt;css代码如下，stage需要设置perspective，wrapper要定义transform-style: preserve-3d。&lt;/p&gt;

&lt;p&gt;对于img，首先通过absolute让一组元素重叠起来，然后分别设置旋转角度，六张图片，角度均匀分布的话，每个应该相差60度，此时六个图片仍然重叠在一起，只是各自面向不同的方位，接下来就是一个重要的设置：translateZ。&lt;/p&gt;

&lt;p&gt;当元素面向浏览器（没有rotateX或者Y）时，translateZ的运动垂直于浏览器所在的平面，而设置了旋转之后，z轴会分别垂直于各个元素旋转之后所在的平面，因此，对于不同方向的img，translateZ相当于让它们像花儿开放一样，手拉手，背对背，分散开来～&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;
    .stage {
        perspective: 800px;
        position: relative;
        height: 400px;
    }
    .wrapper {
        transform-style: preserve-3d;
        height: inherit;
    }
    .wrapper img {
        position: absolute;
        width: 108px;
        height: 108px;
        padding: 10px;
        background: #eee;
        left: 200px;
    }
    .wrapper img:nth-child(1) { transform: rotateY(   0deg ) translateZ(150px); }
    .wrapper img:nth-child(2) { transform: rotateY(  60deg ) translateZ(150px); }
    .wrapper img:nth-child(3) { transform: rotateY( 120deg ) translateZ(150px); }
    .wrapper img:nth-child(4) { transform: rotateY( 180deg ) translateZ(150px); }
    .wrapper img:nth-child(5) { transform: rotateY( 240deg ) translateZ(150px); }
    .wrapper img:nth-child(6) { transform: rotateY( 300deg ) translateZ(150px); }

    @keyframes rotatehaha {
        0% {transform: rotateY(0deg);}
        16% {transform: rotateY(60deg);}
        32% {transform: rotateY(120deg);}
        48% {transform: rotateY(180deg);}
        64% {transform: rotateY(240deg);}
        80% {transform: rotateY(300deg);}
    }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;over。如果要旋转整个相册，给wrapper元素加上transform: rotateY(${num}deg)就可以。自动旋转的话，可以写个小动画：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.wrapper {
    transform-style: preserve-3d;
    height: inherit;
    animation: rotatehaha 10s infinite;
}

@keyframes rotatehaha {
    0% {transform: rotateY(0deg);}
    16% {transform: rotateY(60deg);}
    32% {transform: rotateY(120deg);}
    48% {transform: rotateY(180deg);}
    64% {transform: rotateY(240deg);}
    80% {transform: rotateY(300deg);}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于上边设置的3D相关的属性，可以在浏览器审查元素中通过上下键改变值的大小，感受全方位360度的视角，加深理解…&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zhangxinxu.com/wordpress/2012/09/css3-3d-transform-perspective-animate-transition/&quot;&gt;阅读更多&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 25 May 2016 10:41:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/css3/2016/05/25/%E4%BD%BF%E7%94%A8css%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%89%E7%BB%B4%E7%AB%8B%E4%BD%93%E6%97%8B%E8%BD%AC%E7%9B%B8%E5%86%8C.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/css3/2016/05/25/%E4%BD%BF%E7%94%A8css%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%89%E7%BB%B4%E7%AB%8B%E4%BD%93%E6%97%8B%E8%BD%AC%E7%9B%B8%E5%86%8C.html</guid>
        
        
        <category>css3</category>
        
      </item>
    
      <item>
        <title>react context传值</title>
        <description>&lt;p&gt;用react-router的时候，希望给{this.props.children}这个组件传一个layout里的用户名…&lt;/p&gt;

&lt;p&gt;Layout.js中：&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const Layout = React.createClass({
    childContextTypes: {
        username: React.PropTypes.string
    },
    getChildContext() {
        return {
            username: this.state.username
        };
    },
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;子组件中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const DateRange = React.createClass({
    contextTypes: {
        username: React.PropTypes.string
    },

    ...
    render() {
        const { username } = this.context;
        return ...
    }
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://facebook.github.io/react/docs/context.html&quot;&gt;更多关于context&lt;/a&gt;
&lt;a href=&quot;http://facebook.github.io/react/docs/reusable-components.html&quot;&gt;更多propTypes&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 05 May 2016 17:40:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/context/2016/05/05/react-context.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/context/2016/05/05/react-context.html</guid>
        
        
        <category>react</category>
        
        <category>context</category>
        
      </item>
    
      <item>
        <title>echarts中需要保持legend的selected状态</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;背景：&lt;/h1&gt;

&lt;p&gt;图表随着时间“自动更新”时，假如deSelect了某一项数据，在下次数据来临、图刷新时，依然deSelect这个数据项。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;思路：&lt;/h1&gt;

&lt;p&gt;在公共的Chart组件中：
&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
getInitialState() {
    return {
        selected: {}
    }
},
componentDidUpdate() {
    const el = this.getDOMNode();
    const myChart = echarts.init(el);

    const { selected } = this.state;
    // 如果没有改变select状态，selected将为空
    const ifSelected = this.isEmpty(selected);

    if (ifSelected) {
        myChart.setOption(this.props[&#39;data-source&#39;]);
    }
    else {
        // 手动设置legend.selected
        this.props[&#39;data-source&#39;].legend.selected = selected;
        myChart.setOption(this.props[&#39;data-source&#39;]);
    }

    const _this = this;
    // echarts添加事件监测
    myChart.on(&#39;legendselectchanged&#39;, function(obj) {
        var selected = obj.selected;
        var legend = obj.name;
        _this.setState({
            selected: selected
        });
    });
},
isEmpty(obj) {
    for (var name in obj) {
        return false;
    }
    return true;
},
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://echarts.baidu.com/api.html#events&quot;&gt;更多事件API&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Apr 2016 16:57:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/echarts/2016/04/19/echarts-%E4%BF%AE%E6%94%B9legend%E7%9A%84select%E7%8A%B6%E6%80%81.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/echarts/2016/04/19/echarts-%E4%BF%AE%E6%94%B9legend%E7%9A%84select%E7%8A%B6%E6%80%81.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
        <category>echarts</category>
        
      </item>
    
      <item>
        <title>react native初次会面</title>
        <description>&lt;p&gt;preparation: XCode&lt;/p&gt;

&lt;h1 id=&quot;install&quot;&gt;install&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo npm install -g react-native-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;init-a-project&quot;&gt;init a project&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ react-native init `${projectname}`
$ cd `${projectname}`
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;start&quot;&gt;start&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ react-native run-ios
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;a href=&quot;http://facebook.github.io/react-native/docs/getting-started.html&quot;&gt;read more&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Apr 2016 16:07:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react-native/2016/04/19/first-step-to-reactnative.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react-native/2016/04/19/first-step-to-reactnative.html</guid>
        
        
        <category>react-native</category>
        
      </item>
    
      <item>
        <title>echarts多图时页面resize事件以及重绘需要判断</title>
        <description>&lt;h1 id=&quot;resize&quot;&gt;resize事件&lt;/h1&gt;

&lt;p&gt;当页面上有&amp;gt;1个图表时，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;window.onresize = myChart.resize;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并不能使所有的图响应浏览器resize事件，只有一个随机的图能随着resize。&lt;/p&gt;

&lt;p&gt;于是参考&lt;a href=&quot;https://facebook.github.io/react/tips/dom-event-listeners.html&quot;&gt;DOM Event Listeners in a Component&lt;/a&gt;里所写，添加了resize事件：&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
getInitialState() {
    let innerWidth = window.innerWidth;
    let acWidth;
    if (innerWidth &amp;gt; 991) {
        acWidth = (innerWidth - 144) / 3;
    }
    else {
        acWidth = innerWidth - 60;
    }
    return {
        width: acWidth
    };
},
handleResize() {
    let innerWidth = window.innerWidth;
    let acWidth;
    if (innerWidth &amp;gt; 991) {
        acWidth = (innerWidth - 144) / 3;
    }
    else {
        acWidth = innerWidth - 60;
    }
    this.setState({
        width: acWidth
    });
},
componentDidMount() {
    window.addEventListener(&#39;resize&#39;, this.handleResize);
},
componentWillUnmount() {
    window.removeEventListener(&#39;resize&#39;, this.handleResize);
},
render() {
    const { width } = this.state;
    let option = {
        // 根据echarts配置项手册配置option
    }
    return &amp;lt;Chart data-source={option} height=&quot;300&quot; width={width}/&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，当浏览器窗口缩放时，所有图都会随着重新渲染。但是出现了又一个问题：&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;判断是否需要重新渲染&lt;/h1&gt;

&lt;p&gt;很多时候的重新渲染都是不必要的，如果开启了echarts的animation，就可以看到，页面中其它组件的状态变化也会使echarts重新渲染一遍。&lt;/p&gt;

&lt;p&gt;此时需要&lt;code class=&quot;highlighter-rouge&quot;&gt;shouldComponentUpdate&lt;/code&gt;来限制重绘：&lt;/p&gt;

&lt;p&gt;Chart组件中添加以下代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shouldComponentUpdate: function(nextProps, nextState) {
    let renderFlag = true;

    if ((this.props.width === nextProps.width)
        &amp;amp;&amp;amp; (JSON.stringify(nextProps[&#39;data-source&#39;]) === JSON.stringify(this.props[&#39;data-source&#39;]))) {
        renderFlag = false;
    }
    return renderFlag;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shouldComponentUpdate&lt;/code&gt;的方法返回false时，不重绘。如此，当宽度和数据都没有变化的时候，图将不会重新渲染；页面上图比较多的时候，这样做非常有必要。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;更多关于React-router&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Apr 2016 14:20:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/echarts/2016/04/19/echarts-react-shouldupdate.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/echarts/2016/04/19/echarts-react-shouldupdate.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
        <category>echarts</category>
        
      </item>
    
  </channel>
</rss>
