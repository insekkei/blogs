<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>web前端笔记</title>
    <description>绿螘新醅酒，红泥小火炉。&lt;br&gt;晚来天欲雪，能饮一杯无？
</description>
    <link>http://insekkei.com/blogs//blogs/</link>
    <atom:link href="http://insekkei.com/blogs//blogs/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 19 Feb 2016 13:49:17 +0800</pubDate>
    <lastBuildDate>Fri, 19 Feb 2016 13:49:17 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>react router使用</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;React Router keeps your UI in sync with the URL. It has a simple API with powerful features like lazy code loading, dynamic route matching, and location transition handling built right in.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;npm--more--&quot;&gt;使用npm安装&lt;!--more--&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ npm install --save react-router
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;layoutroutehandler&quot;&gt;在Layout中使用RouteHandler&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;A Layout is something that describes an entire page structure, such as a fixed navigation, viewport, sidebar, and footer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var React = require(&#39;react&#39;);
var RouteHandler = require(&#39;react-router&#39;).RouteHandler;
var Link = require(&#39;react-router&#39;).Link;

...

var Layout = React.createClass({
    ...
    render: function () {
        return (
            &amp;lt;div className=&quot;wrapper&quot;&amp;gt;
                &amp;lt;PlatformHeader/&amp;gt;
                &amp;lt;PlatformNav/&amp;gt;
                &amp;lt;PlatformContent/&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
});

// RouteHandler是react router的核心组件之一，代表与当前路由（url）匹配的组件。
var PlatformContent = React.createClass({
    render: function() {
        return (
            &amp;lt;div className=&#39;main&#39;&amp;gt;
                &amp;lt;RouteHandler/&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
});

// PlatformNav中有url链接（路由需求），例如index
var PlatformNav = React.createClass({
    render: function() {
        return (
            &amp;lt;div className=&#39;nav&#39;&amp;gt;
                ...
                &amp;lt;Link to=&quot;index&quot;&amp;gt;首页&amp;lt;/Link&amp;gt;
                ...
            &amp;lt;/div&amp;gt;
        );
    }
});

...
module.exports = Layout;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;index&quot;&gt;index页&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var Index = React.createClass({
    render: function() {
        return (
            &amp;lt;div&amp;gt;
                Welcome!
            &amp;lt;/div&amp;gt;
        );
    }
});

module.exports = Index;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;appjs&quot;&gt;在app.js中配置路由&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var Layout = require(&#39;./components/Layout&#39;);
var Index = require(&#39;./components/Index&#39;);

// 引入需要的组件
var Router = require(&#39;react-router&#39;).Router;
var Route  = require(&#39;react-router&#39;).Route;
var DefaultRoute = require(&#39;react-router&#39;).DefaultRoute; // 默认路由，首页

// 或使用es6
import { Router, Route, DefaultRoute } from &#39;react-router&#39;

// 设置路由，handler中是组件名称，path写url
var routes = (
    &amp;lt;Route&amp;gt;
        &amp;lt;Route path=&quot;/&quot; handler={Layout}&amp;gt;
            &amp;lt;DefaultRoute handler={Index}/&amp;gt;
            &amp;lt;Route path=&#39;index&#39; name=&#39;index&#39; handler={Index}/&amp;gt;
        &amp;lt;/Route&amp;gt;
    &amp;lt;/Route&amp;gt;
);

Router.run(routes, Router.HistoryLocation, (Root) =&amp;gt; {
    React.render(&amp;lt;Root/&amp;gt;, document.body);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，点击nav中的“首页”链接时，浏览器地址栏中会出现’index’，同时页面上能看到“Welcome”。而刷新页面时，也能根据给当前url分配的组件Index，加载想要看到的内容。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;更多关于React-router&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Feb 2016 11:40:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/2016/02/19/React-Router.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/2016/02/19/React-Router.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>IE9不打开控制台无法正常执行js</title>
        <description>&lt;p&gt;接手一个系统项目，必须运行在windows下，浏览器要求IE9。&lt;/p&gt;

&lt;p&gt;调试脚本的过程中使用过&lt;code&gt;console.log()&lt;/code&gt;，同时页面包含一个&lt;code&gt;setInterval()&lt;/code&gt;方法，每隔300毫秒自动获取接口传过来的数据， 获取到正确的数据之后，停止定时器。&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;chrome中测试无误，然而转到IE9中之后，死活无法等到数据，便想打开控制台看看有没有报错，然而每每一打开控制台几乎瞬间数据就传过来了！试了好多次，确定不是机缘未到，抱着怀疑的心理搜索了一下“ie9 控制台打开才执行js”，果然很多人都遇到过这个问题，但是，故事的结局往往出人意料：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;IE仅在开启developer tools的时候，脚本才能访问到console这个对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这真是一个让人忍不住想吐槽的设定…&lt;/p&gt;

&lt;p&gt;对此情况，解决方案有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;生产环境下移除或者注释掉&lt;code&gt;console.log()&lt;/code&gt; 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为避免报错，这样声明&lt;code&gt;console&lt;/code&gt;：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  var console = console || {
      log : function () {
          return;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自定义封装个方法调用：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  function log(msg){
      if (window.console){
          console.log(msg);
      }
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多内容：&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/dn255006(v=vs.85).aspx&quot;&gt;https://msdn.microsoft.com/zh-cn/library/dn255006.aspx&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 25 Jan 2016 17:32:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/ie/js/2016/01/25/ie9%E6%97%A0%E6%B3%95%E5%85%BC%E5%AE%B9console%E5%AF%B9%E8%B1%A1.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/ie/js/2016/01/25/ie9%E6%97%A0%E6%B3%95%E5%85%BC%E5%AE%B9console%E5%AF%B9%E8%B1%A1.html</guid>
        
        
        <category>ie</category>
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>css实现背景图片局部滤镜加半透明效果</title>
        <description>&lt;p&gt;实现效果预览：&lt;a href=&quot;http://www.daipuarchitects.com/?cat=14&quot;&gt;Daipu Architects&lt;/a&gt; 中间区域。&lt;/p&gt;

&lt;p&gt;html：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;wrapper&quot;&amp;gt;
    &amp;lt;div class=&quot;overlay&quot;&amp;gt;
        &amp;lt;div class=&quot;overlay-con&quot;&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;父级div，一般背景图会覆盖浏览器可视区域：&lt;!--more--&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.wrapper{
    ...
    width: 100%;
    height: 100%;
    background: url(image.png);
    background-size: cover;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模糊背景层，固定宽度，高度为js计算得出，:after设置模糊效果，如果在child上设置，包含文字也会模糊掉:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.overlay{
    ...
    width: 750px;
    position: absolute;
    bottom: 0;
    left: 50%;
    margin-left: -375px;
    background: inherit;
    ...

    &amp;amp;:after {
        content: &quot;&quot;;
        display: block;
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        background: inherit;
        z-index: 0;
        -webkit-filter: blur(3px);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文字层div：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.overlay-con {
    background: rgba(255,255,255,.6);
    position: relative;
    z-index: 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结：没想到&lt;code&gt;background:inherit&lt;/code&gt;会带来这么大的惊喜～&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Jan 2016 17:21:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/css/2016/01/25/css%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E5%9B%BE%E5%B1%80%E9%83%A8%E6%BB%A4%E9%95%9C%E5%8A%A0%E5%8D%8A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/css/2016/01/25/css%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E5%9B%BE%E5%B1%80%E9%83%A8%E6%BB%A4%E9%95%9C%E5%8A%A0%E5%8D%8A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C.html</guid>
        
        
        <category>css</category>
        
      </item>
    
      <item>
        <title>forever守护进程相关记录</title>
        <description>&lt;h2 id=&quot;forever&quot;&gt;安装forever&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ npm install forever -g
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;forever-1&quot;&gt;使用forever&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;用法一：&lt;/h3&gt;

&lt;p&gt;例如：后台定时运行一个phantomjs截图的任务。&lt;/p&gt;

&lt;p&gt;phantmjs截图的代码写在pagename.js中：
&lt;!--more--&gt;
    var page = require(‘webpage’).create();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;page.open(&#39;pageurl&#39;, function() {
    page.render(&#39;imagePath&#39;);
    phantom.exit();
});
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定时任务写在capturePage.js中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var childProcess = require(&#39;child_process&#39;);

getImageDaily();

function getImageDaily() {
    getImageByDate(date, function () {
        // 一小时后再更新
        setTimeout(function () {
            getImageDaily();
        }, 60*60000);
    }, function (error, stdout) {
        ...
    });
}

getImageByDate(date) {
    childProcess.exec(&#39;phantomjs pagename.js&#39;, function (error, stdout, stderr) {
        ...
    });
}

app.listen(port || 8888);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行&lt;code&gt;$ forever start capturePage.js&lt;/code&gt;后，查看node进程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ps aux|grep node

xxx           13169   0.0  0.4  3058580  33252   ??  S     5:02PM   0:00.22 /usr/local/bin/node /Users/baidu/Documents/xxx/capturePage.js
xxx           13168   0.0  0.5  3057732  39420   ??  Ss    5:02PM   0:00.37 /usr/local/bin/node /usr/local/lib/node_modules/forever/bin/monitor capturePage.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多出了一个monitor的进程，然后，杀死13169即capturePage.js的进程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kill 13169
$ ps aux|grep node

xxx           13176   0.0  0.4  3058580  33144   ??  S     5:05PM   0:00.22 /usr/local/bin/node /Users/baidu/Documents/xxx/capturePage.js
xxx           13168   0.0  0.5  3057732  39740   ??  Ss    5:02PM   0:00.38 /usr/local/bin/node /usr/local/lib/node_modules/forever/bin/monitor capturePage.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，杀死capturePage.js之后，capturePage.js重启了，进程号不同了。&lt;/p&gt;

&lt;h3 id=&quot;forever-monitorcapturepagejs&quot;&gt;用法二：安装forever-monitor，编码式监控capturePage.js&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ npm install forever-monitor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建文档monitor.js：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var forever = require(&#39;forever-monitor&#39;);

var child = new (forever.Monitor)(&#39;capturePage.js&#39;, {
    max: 3,
    silent: true,
    args: []
});

child.on(&#39;exit&#39;, function () {
    console.log(&#39;your-filename.js has exited after 3 restarts&#39;);
});

child.start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后台执行monitor.js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ node monitor.js &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优点是，自主可控，缺点是，自己写的，功能不会很完善，当然比不上forever命令，还有日志管理等等。&lt;/p&gt;

&lt;p&gt;资料参考：&lt;a href=&quot;https://github.com/foreverjs/forever-monitor&quot;&gt;forever-monitor&lt;/a&gt;、&lt;a href=&quot;https://github.com/foreverjs/forever&quot;&gt;forever&lt;/a&gt;、&lt;a href=&quot;http://phantomjs.org/screen-capture.html&quot;&gt;phantomjs&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Jan 2016 16:35:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/node/forever/phantomjs/2016/01/25/forever%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/node/forever/phantomjs/2016/01/25/forever%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95.html</guid>
        
        
        <category>node</category>
        
        <category>forever</category>
        
        <category>phantomjs</category>
        
      </item>
    
      <item>
        <title>gulp打包编译速度优化</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;保持对新技术的好奇心，深入研究当前工作使用的技术，同时进行一些输出，例如写博客，做开源，研究分享，写书等的，没有输出的学习就是耍流氓。
——来自知乎&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;做项目时使用了browserify，但每次修改编译时间都很长，十几秒的样子？&lt;!--more--&gt;反正感觉等待编译的时间已经远远超过了修改代码的时间，忍无可忍之时，开始寻找解决方案。&lt;/p&gt;

&lt;p&gt;于是很快就找到了watchify，简单理解，就是增量编译。&lt;/p&gt;

&lt;p&gt;修改之前：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var source = require(&#39;vinyl-source-stream&#39;);
var browserify = require(&#39;browserify&#39;);
var streamify = require(&#39;gulp-streamify&#39;);

gulp.task(&#39;browserify&#39;, function () {
    var bundleStream = browserify(&#39;v1/js/app.js&#39;).bundle();

    return bundleStream
    .pipe(source(&#39;app.js&#39;))
    .pipe(streamify(uglify()))
    .pipe(gulp.dest(&#39;./dev/js/&#39;));
});

// after each change, execute browserify, make a long long progress...
gulp.task(&#39;release&#39;, [&#39;browserify&#39;], function () {
    return gulp.src(&#39;./dev/js/app.js&#39;)
    .pipe(gulp.dest(&#39;../static/js/&#39;));
});

// watch everything
gulp.task(&#39;watch&#39;, function () {
    gulp.watch([&#39;v1/less/**/*&#39;], [&#39;css2js&#39;]);
    gulp.watch([&#39;v1/js/**/*&#39;], [&#39;release&#39;]);
});

...
gulp.task(&#39;default&#39;, [&#39;release&#39;, &#39;watch&#39;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加watchify：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var watchify = require(&#39;watchify&#39;); 
var source = require(&#39;vinyl-source-stream&#39;);
var browserify = require(&#39;browserify&#39;);
var streamify = require(&#39;gulp-streamify&#39;);
var assign = require(&#39;lodash.assign&#39;);

var bundleStream = watchify(browserify(assign({}, watchify.args, {
    // required for watchify
    cache: {},
    // required for watchify
    packageCache: {},
    entries: [&#39;v1/js/app.js&#39;]
}))); 

gulp.task(&#39;browserify&#39;, bundle);
// on any dep update, runs the bundler
bundleStream.on(&#39;update&#39;, bundle);
// output build logs to terminal
bundleStream.on(&#39;log&#39;, gutil.log);

function bundle() {  
  return bundleStream.bundle()
    // log errors if they happen
    .on(&#39;error&#39;, gutil.log.bind(gutil, &#39;Browserify Error&#39;))
    .pipe(source(&#39;app.js&#39;))
    .pipe(streamify(uglify()))
    .pipe(gulp.dest(&#39;./dev/js/&#39;));
}

// browserify will not need
gulp.task(&#39;release&#39;, function () {
    return gulp.src(&#39;./dev/js/app.js&#39;)
    .pipe(gulp.dest(&#39;../static/js/&#39;));
});

gulp.task(&#39;watch&#39;, function () {
    gulp.watch([&#39;v1/less/**/*&#39;], [&#39;css2js&#39;]);
    // just watch one file produced by WATCHIFY
    gulp.watch([&#39;./dev/js/app.js&#39;], [&#39;release&#39;]);
});

...
// only at the beginning browserify being executed
gulp.task(&#39;default&#39;, [&#39;browserify&#39;, &#39;watch&#39;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;延伸阅读及参考资料：&lt;/p&gt;

&lt;p&gt;http://csspod.com/advanced-tips-for-using-gulp-js/&lt;/p&gt;

&lt;p&gt;http://csspod.com/using-browserify-with-gulp/&lt;/p&gt;
</description>
        <pubDate>Mon, 21 Dec 2015 11:28:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/gulp/browserity/2015/12/21/gulp%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/gulp/browserity/2015/12/21/gulp%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96.html</guid>
        
        
        <category>gulp</category>
        
        <category>browserity</category>
        
      </item>
    
      <item>
        <title>flux中使用react-loder</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;做一个react的项目，需要loading菊花的效果，找到了&lt;a href=&quot;https://github.com/quickleft/react-loader&quot;&gt;react-loader&lt;/a&gt;，然而README中只有一些不明觉厉的伪代码…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;经过多番尝试，终于做出来了一款flux的小菊花…三木君说，这种方法藕合度挺高的。然而我目前想不到更好（kuai，四声）&lt;!--more--&gt;的方法来对付手头的flux项目了…如果谁有思路，请&lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#104;&amp;#097;&amp;#110;&amp;#099;&amp;#111;&amp;#110;&amp;#103;&amp;#057;&amp;#049;&amp;#048;&amp;#052;&amp;#064;&amp;#049;&amp;#054;&amp;#051;&amp;#046;&amp;#099;&amp;#111;&amp;#109;&quot;&gt;务必告知&lt;/a&gt;，不胜感激。&lt;/p&gt;

&lt;p&gt;In the view:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Loader loaded={!this.state.data.isLoading} ... /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When send a xhr request:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
componentDidMount: function () {
    sampleStore.addChangeListener(this._change);

    if (this.isMounted()) {
        // 发请求之前都先setIsLoading
        SampleActions.setIsLoading();
        SampleActions.loadData(); 
    }
},
..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And in SampleActions.js:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
setIsLoading: function (params) {
    PlatformDispatcher.dispatch({
        actionType: &#39;order_statistic_set_isLoading&#39;,
        item: params
    });
},
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, in sampleStore.js:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PlatformDispatcher.register(function (payload) {
    var actionType = payload.actionType;

    switch (actionType) {
        ...
        case &#39;order_statistic_set_isLoading&#39;:
          orderStatisticStore.setIsLoading(payload.item);
          break;
        ...
    }
});

OrderStatisticStore.prototype = assign({}, EventEmitter.prototype, {
    setIsLoading: function (params) {
        // when send a xhr request, change state
        this.data.isLoading = true;
        this.emit(&#39;change&#39;);
    },
    loadData: function (params, callback) {
        var params = params || {};

        // send request
        PlatformRequest.getQuestHandle({
            url: ...,
            data: {
                ...
            }
        }, function (res) {
            // when success, change the state of isLoading
            this.data.isLoading = false;
            this.data... = res;
            this.emitChange();
            callback &amp;amp;&amp;amp; callback();
        }.bind(this));
    },
    ...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果再配合bootstrap-react的loading button state，也是美呆了…&lt;/p&gt;
</description>
        <pubDate>Thu, 24 Sep 2015 15:07:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/loader/2015/09/24/react-loader-with-flux.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/loader/2015/09/24/react-loader-with-flux.html</guid>
        
        
        <category>react</category>
        
        <category>loader</category>
        
      </item>
    
      <item>
        <title>用react完成一个带省略号的分页</title>
        <description>&lt;p&gt;分页其实想起来很容易：不过就是从后台拿一些数据来——当前页码、总页数、总条目数、每页显示的数量等等。&lt;/p&gt;

&lt;p&gt;本篇将完成一个具备以下简单功能的react组件（结合Flux）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;页码list&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;首页、末页、上下页&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;页码数量过多时用省略号指引&lt;!--more--&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;section&quot;&gt;组件将被这样使用：&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Pagination currentPn={currentPn}
        pageCount={pageCount}
        pageSize={pageSize}
        dataSize={dataSize}
        clickHandler={this.changePn}
        prevHandler={this.prevPn}
        nextHandler={this.nextPn}
        firstHandler={this.firstPn}
        lastHandler={this.lastPn}
&amp;gt;
&amp;lt;/Pagination&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;点击每一个list中的页码链接，执行&lt;code&gt;this.changePn&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;changePn: function (e) {
    e.preventDefault();
    ExampleActions.setPageNumber({
        pageNumber: e.target.innerHTML
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上下页翻页方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;prevPn: function (e) {
    e.preventDefault();
    ExampleActions.setPageNumber({
        pageNumber: currentPn － 1
    });
},
nextPn: function (e, currentPn) {
    e.preventDefault();
    ExampleActions.setPageNumber({
        pageNumber: currentPn ＋ 1
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首页和末页方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;firstPn: function (e) {
    e.preventDefault();
    ExampleActions.setPageNumber({
        pageNumber: 1
    });
},
lastPn: function (e, currentPn) {
    e.preventDefault();
    ExampleActions.setPageNumber({
        pageNumber: pageCount
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述五个方法执行后，通过action调用dispatcher，dispatcher调用store，store中loadData，重新render组件这个过程更新页面中展示的数据。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;组件将被这样实现：&lt;/h1&gt;

&lt;p&gt;定义变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var pageList = &#39;&#39;;
var pageListArr = [];
var prevPage = &#39;&#39;;
var nextPage = &#39;&#39;;
var firstPage = &#39;&#39;;
var lastPage = &#39;&#39;;
var thisProps = this.props;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;展示页码list并不难，取到上面使用组件时传递过来的属性，将pageCount肢解，遍历，加入标签组装就可以完成这个任务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (var i = 0; i &amp;lt; thisProps.pageCount; i++) {
    pageListArr.push(i);
};
pageList = pageListArr.map(function (item) {
    // 判断是否当前页
    if (item === thisProps.currentPn) {
        return (
            &amp;lt;li className=&quot;active&quot;&amp;gt;&amp;lt;a href=&quot;&quot; onClick={thisProps.clickHandler}&amp;gt;
                {item}&amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
    else {
        return (
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;&quot; onClick={thisProps.clickHandler}&amp;gt;
                {item}&amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上下页翻页链接，要判断是否可点击，首页和末页类似，但不需要判断状态：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 上一页
prevPage = (function () {
    if (thisProps.currentPn === 1) {
        return (
            &amp;lt;li className=&quot;disabled&quot;&amp;gt;
              &amp;lt;span&amp;gt;
                &amp;lt;span aria-hidden=&quot;true&quot;&amp;gt;上一页&amp;lt;/span&amp;gt;
              &amp;lt;/span&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
    else {
        return (
            &amp;lt;li&amp;gt;
              &amp;lt;a href=&quot;#&quot; aria-label=&quot;Previous&quot; onClick={thisProps.prevHandler}&amp;gt;
                &amp;lt;span aria-hidden=&quot;true&quot;&amp;gt;上一页&amp;lt;/span&amp;gt;
              &amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
})();

// 下一页
nextPage = (function () {
    if (thisProps.currentPn === thisProps.pageCount) {
        return (
            &amp;lt;li className=&quot;disabled&quot;&amp;gt;
              &amp;lt;span&amp;gt;
                &amp;lt;span aria-hidden=&quot;true&quot;&amp;gt;下一页&amp;lt;/span&amp;gt;
              &amp;lt;/span&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
    else {
        return (
            &amp;lt;li&amp;gt;
              &amp;lt;a href=&quot;#&quot; aria-label=&quot;Next&quot; onClick={thisProps.nextHandler}&amp;gt;
                &amp;lt;span aria-hidden=&quot;true&quot;&amp;gt;下一页&amp;lt;/span&amp;gt;
              &amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;组装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul className=&quot;pagination pull-right&quot;&amp;gt;
    {firstPage}
    {prevPage}
    {pageList}
    {nextPage}
    {lastPage}
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-2&quot;&gt;显示省略号&lt;/h1&gt;

&lt;p&gt;考虑四种情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;左边右边都不需要省略号&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;左边有省略号，右边没有&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;左边没有省略号，右边有&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;左右两边都需要省略号&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;再考虑：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“首页”和“末页”可以用“1”“100（假设是最后一页的页码）”放在list中代替，因为不管有没有省略号，1和100始终都要显示出来。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两种实现思路：&lt;/p&gt;

&lt;p&gt;1、四种不同的情况下，直接拼装包含&lt;code&gt;...&lt;/code&gt;的html代码&lt;/p&gt;

&lt;p&gt;2、四种不同的情况下，先拼装pageListArr这个变量，再遍历生成html代码&lt;/p&gt;

&lt;p&gt;考虑到react中store影响view这个特性，我决定采用第二种方法（我不会告诉你其实我先尝试了第一种方法，然后拼装变量和字符串快要崩溃…jsx都不完全懂，还是默默地去操作变量吧…何况这样真的比较清爽…）&lt;/p&gt;

&lt;p&gt;添加变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 假设当前页码总在中间显示，pageTab就是当前页码到省略号之间的数量，比如1...4,5,6,7,8...100，pageTab就是2
var pageTab = 4;

// 左边的省略号，在第1页之后
var leftEllipse = &#39;&#39;;

// 右边的省略号，在第100页之前
var rightEllipse = &#39;&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总页数小于11，全部显示（这里可以做成可配置的）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (thisProps.pageCount &amp;lt; 11) {

    // 注意pageListArr要先清空
    pageListArr = [];

    // 从第二页开始显示，到倒数第二页
    for (var i = 1; i &amp;lt; thisProps.pageCount-1; i++) {
        pageListArr.push(i);
    };

    //左右都没有省略号
    leftEllipse = &#39;&#39;;
    rightEllipse = &#39;&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总页码数大于11时，有&lt;code&gt;...&lt;/code&gt;出现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (thisProps.pageCount &amp;gt; 10) {
    // 当前页减去pageTab小于1，右边显示省略号，左边不显示
    if (thisProps.currentPn - pageTab &amp;lt; 1) {

        pageListArr = [];

        for (var i = 1; i &amp;lt; 10; i++) {
            pageListArr.push(i);
        };

        leftEllipse = &#39;&#39;;
        rightEllipse = &amp;lt;li&amp;gt;&amp;lt;span&amp;gt;...&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;;
    }

    // 当前页减去pageTab大于1 且 当前页加上pageTab小于总页数，两边都显示省略号
    if ((thisProps.currentPn - pageTab &amp;gt; 1) &amp;amp;&amp;amp; ((thisProps.currentPn + pageTab) &amp;lt; thisProps.pageCount)) {

        pageListArr = [];

        for (var i = thisProps.currentPn - pageTab; i &amp;lt; thisProps.currentPn + pageTab; i++) {
            pageListArr.push(i);
        };

        leftEllipse = &amp;lt;li&amp;gt;&amp;lt;span&amp;gt;...&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;;
        rightEllipse = &amp;lt;li&amp;gt;&amp;lt;span&amp;gt;...&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;
    }

    // 当前页码加上pageTab大于总页数，右边不显示省略号，左边显示
    if ((thisProps.currentPn + pageTab) &amp;gt; (thisProps.pageCount)) {

        pageListArr = [];

        for (var i = thisProps.pageCount - (pageTab*2 + 1); i &amp;lt; thisProps.pageCount; i++) {
            pageListArr.push(i);
        };

        leftEllipse = &amp;lt;li&amp;gt;&amp;lt;span&amp;gt;...&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;;
        rightEllipse = &#39;&#39;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首页和末页：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 首页
firstPage = (function () {
    if (thisProps.currentPn === 1) {
        return (
            &amp;lt;li className=&quot;active&quot;&amp;gt;&amp;lt;a href=&quot;&quot; onClick={thisProps.firstHandler}&amp;gt;
                1&amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
    else {
        return (
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;&quot; onClick={thisProps.firstHandler}&amp;gt;
                1&amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
})();

// 末页
lastPage = (function () {
    if (thisProps.currentPn === thisProps.pageCount) {
        return (
            &amp;lt;li className=&quot;active&quot;&amp;gt;&amp;lt;a href=&quot;&quot; onClick={thisProps.lastHandler}&amp;gt;
                {thisProps.pageCount}&amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
    else {
        return (
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;&quot; onClick={thisProps.lastHandler}&amp;gt;
                {thisProps.pageCount}&amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
        );
    }
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;装入&lt;code&gt;ul&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul className=&quot;pagination pull-right&quot;&amp;gt;
    {prevPage}
    {firstPage}
    {leftEllipse}
    {pageList}
    {rightEllipse}
    {lastPage}
    {nextPage}
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总的组织结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Pagination = React.createClass({
    render: function () {
        ...算法／过程...
        return (
            &amp;lt;ul&amp;gt;
                ...组装结果...
            &amp;lt;/ul&amp;gt;
        );
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，传递过来的dataSize、pageSize还可以展示出来，写一个总结：本页共有xx条数据，等等..&lt;/p&gt;

&lt;p&gt;pageSize也可以做成select形式的，用户可以调整每页展示的数量…&lt;/p&gt;

&lt;p&gt;备注：分页样式使用bootstrap。&lt;/p&gt;
</description>
        <pubDate>Mon, 07 Sep 2015 19:18:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/2015/09/07/js-react-pagination.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/2015/09/07/js-react-pagination.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>react ajax跨域请求</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;同源策略&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy&quot;&gt;同源策略&lt;/a&gt;限制了一个源（origin）中加载文本或脚本与来自其它源（origin）中资源的交互方式。如果两个页面拥有相同的 &lt;code&gt;协议（protocol）&lt;/code&gt;，&lt;code&gt;端口&lt;/code&gt;（如果指定），和 &lt;code&gt;主机&lt;/code&gt;，那么这两个页面就属于同一个源（origin）。&lt;!--more--&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在使用XMLHttpRequest时会受到同源策略的约束。&lt;/p&gt;

&lt;p&gt;浏览器发送的请求header中包含一个&lt;code&gt;Origin&lt;/code&gt;，而服务器返回给浏览器的响应header中包含一个&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;，因此：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;可以通过设置&lt;code&gt;Access-Control-Allow-Origin:&lt;/code&gt;来允许跨域请求，origin的值可以设置为｀*｀，表示接受来自任何站点的跨域请求，也可以设置为特定的域，表示只有这个域能跨域请求到服务器上的数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot;&gt;cors(Cross-Origin Resource Sharing)&lt;/a&gt;可以实现跨域访问，但cors只支持现代浏览器。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;jsonp&quot;&gt;jsonp&lt;/h1&gt;

&lt;p&gt;jsonp（json with padding），一种包含在函数调用中的json。解决跨域请求比较可靠的一种思路是：设置&lt;code&gt;dataType&lt;/code&gt;为&lt;code&gt;jsonp&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;普通的json格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&#39;name&#39;: &#39;insekkei&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jsonp格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;callback(
    {&#39;name&#39;: &#39;insekkei&#39;}
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即：调用jsonp回调函数callback，并将返回的json作为参数传入这个回调函数。&lt;code&gt;callback&lt;/code&gt;是jsonp请求默认的回调函数名称，会在请求url中追加&lt;code&gt;?callback=?&lt;/code&gt;，也可以自定义这个名称：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dataType : &#39;jsonp&#39;,
jsonp: &#39;callbackName&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时服务器需要返回的数据格式为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;callbackName(
    {&#39;name&#39;: &#39;insekkei&#39;}
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显而易见，jsonp不仅需要客户端js进行配置，也需要服务器端返回数据格式的配合。不过，&lt;code&gt;jsonp只支持get请求...&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&quot;superagent&quot;&gt;superagent&lt;/h1&gt;

&lt;p&gt;react中需要ajax请求时，可以使用&lt;a href=&quot;https://cnodejs.org/topic/5378720ed6e2d16149fa16bd&quot;&gt;superagent&lt;/a&gt;这个模块，例如一个get请求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var request = require(&#39;superagent&#39;);

request
    .get(url)
    .set(&#39;Accept&#39;, &#39;application/json&#39;)
    .query(paramObj)
    .end(function(res){
        // do something
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;post方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;request
    .post(url)
    .send(dataObj)
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而有时候需要跨域请求数据，如果只是使用上面的方法，控制台会出现类似如下提示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;XMLHttpRequest cannot load http://xxx.xx.... No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;http://yyy.yy...&#39; is therefore not allowed access.
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;superagent-jsonp&quot;&gt;superagent-jsonp&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/superagent-jsonp&quot;&gt;superagent-jsonp&lt;/a&gt;为superagent添加了jsonp方法。&lt;/p&gt;

&lt;p&gt;安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm i superagent-jsonp --save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var request = require(&#39;superagent&#39;);
var superagent = require(&#39;superagent&#39;);
require(&#39;superagent-jsonp&#39;)(request);

request
    .get(url)
    .jsonp()
    .end(function(){
        // do something...
    });
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Wed, 02 Sep 2015 10:10:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/ajax/2015/09/02/js-react%E8%B7%A8%E5%9F%9F.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/ajax/2015/09/02/js-react%E8%B7%A8%E5%9F%9F.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
        <category>ajax</category>
        
      </item>
    
      <item>
        <title>react&amp;flux之BasicSelect组件实现</title>
        <description>&lt;p&gt;应工作需求，用到flux，为了解react设计思想及其flux强调的数据流，查找了各种在线资料，终于可以开工了。然而编码的时候时常产生一种怀疑：我真的是一个前端？&lt;/p&gt;

&lt;h1 id=&quot;react&quot;&gt;React&lt;/h1&gt;

&lt;p&gt;对于react，我是从&lt;a href=&quot;http://facebook.github.io/react/docs/getting-started.html&quot;&gt;这里&lt;/a&gt;开始了解的，然而这儿仅仅能了解到react的语法。&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;对于习惯了html＋css＋js文件的我来说，乍一看到react的代码，第一反应是：html写在js中？这不就是前端一直强调的“结构、样式、行为分离”思想的反面教材吗？不能再颠覆啊！我感到无所适从。&lt;/p&gt;

&lt;p&gt;于是，我想应该先了解下react的设计思想，因此，我跳过了&lt;a href=&quot;http://facebook.github.io/react/docs/tutorial.html&quot;&gt;Tudorial&lt;/a&gt;，从&lt;a href=&quot;http://facebook.github.io/react/docs/thinking-in-react.html&quot;&gt;Thinking in React&lt;/a&gt;开始看起。&lt;/p&gt;

&lt;p&gt;在&lt;a href=&quot;http://facebook.github.io/react/docs/thinking-in-react.html&quot;&gt;Thinking in React&lt;/a&gt;页面我看到了一个很实用的栗子，然后快速地抓住了使用react编码的两个关键字：拆分、组件复用。&lt;/p&gt;

&lt;p&gt;因此，即使很多东西比如select、radio button、弹窗、react都没有都需要从0开始写，就组件复用这一处优点，它也是值得被使用的。&lt;/p&gt;

&lt;h1 id=&quot;flux&quot;&gt;flux&lt;/h1&gt;

&lt;p&gt;什么是flux？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;比起框架，flux更像是一种模式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;React只是引入了虚拟DOM的机制，在view层实现可复用的web前端组件，但她并没有什么数据绑定，依赖诸如这些特性，于是单纯用react的话，数据怎么管理？&lt;/p&gt;

&lt;p&gt;Flux是facebook推出的一个组织web应用开发的架构，它只是一种模式，一种设计思想，因此，对于不同的js库，必然会有不同的实现方式，react只是其中一种。&lt;/p&gt;

&lt;p&gt;在flux中，view和controller是一体的，同时它增加的两层内容：dispatcher和stores，前者负责创建actions，然后将actions按照名称（&lt;code&gt;actionType&lt;/code&gt;）分发给stores，stores中对数据进行修改，触发一些change相关的方法，将改动渲染到view层（一般先是最高层级的组件收到新的数据，再把这些数据传递到子组件中）。简单说就是：&lt;/p&gt;

&lt;p&gt;Action -&amp;gt; Dispatcher -&amp;gt; Store -&amp;gt; View…&lt;/p&gt;

&lt;p&gt;与angular双向数据绑定不同，flux中数据流向永远是单向的，因此带来的好处是：我不必思考当前数据应该传递给谁。&lt;/p&gt;

&lt;p&gt;实战总是比理论让人理解得更加深刻。于是在写了几个查询数据的模块之后，将一点心得在这里记录下来，方便以后查看。&lt;/p&gt;

&lt;h1 id=&quot;select&quot;&gt;一个select组件实例&lt;/h1&gt;

&lt;p&gt;这里将通过一个select组件的实现过程描述flux的数据流。&lt;/p&gt;

&lt;h2 id=&quot;configjs&quot;&gt;静态数据：config.js&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;terminalArr: [
    {
        key: &#39;x&#39;,
        val: &#39;0&#39;
    },
    {
        key: &#39;xx&#39;,
        val: &#39;1&#39;
    },
    {
        key: &#39;xxx&#39;,
        val: &#39;2&#39;
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;examplejs&quot;&gt;Example.js&lt;/h2&gt;

&lt;p&gt;顶层view组件，监测stores变化，并将新的queryObj传递给组件的formData属性，由顶级组件向下分发数据。&lt;/p&gt;

&lt;p&gt;注意对props和state的理解：组件内部使用state，组件之间的通信靠props，比如这里，queryObj数据是Example的state（是在Example内部setState的），queryObj被传递给了ExampleForm这个高层组件，这时候，这个queryObj就变成了ExampleForm的props数据了。然后，ExampleForm内部的Select等组件就都可以使用formData了，通过同样的属性赋值方法传递给下游的组件去使用。&lt;/p&gt;

&lt;pre&gt;var Example = React.createClass({
	
    componentDidMount: function () {
        exampleStore.addChangeListener(this._change);

        if (this.isMounted()) {
            exampleStore.loadData();
        }
    },
    componentWillUnmount: function () {
        exampleStore.removeChangeListener(this._change);
    },
    _change: function () {
        // 只要store有变化，emit(&#39;change&#39;)执行了，就setState
        this.setState(exampleStore.queryObj);
    },
    render: function () {
        return (
        	&amp;lt;div&amp;gt;
        		...
                &amp;lt;ExampleForm formData={this.state.queryObj}/&amp;gt;
                ...
            &amp;lt;/div&amp;gt;
        );
    }
});
&lt;/pre&gt;

&lt;p&gt;中间组件，从formData中取出特定数据，传递给再下游的组件作为属性（props）值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var ExampleForm = React.createClass({
    render: function () {
        var formData = this.props.formData;
        return (
            &amp;lt;form&amp;gt;
                ...
                &amp;lt;TerminalsSelect terminal={formData.terminal}&amp;gt;&amp;lt;/Terminals&amp;gt;
                ...
            &amp;lt;/form&amp;gt;
        );
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续向下，当select change时，调用action中的方法，其中select使用了已经定义好的BasicSelect组件，因此需要传递一些参数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var TerminalsSelect =  React.createClass({
    changeTerminalHandler: function (e) {
        // view -&amp;gt; action
        // 如果在这里直接通过this.setState方法去更新terminal的值，也可以达到相同的目的，但数据流向就出现问题了。
        ExampleActions.setTerminal({
            terminal: e.target.value
        });
    },
    render: function () {
        return (
            &amp;lt;div className=&quot;form-group&quot;&amp;gt;
                &amp;lt;label htmlFor=&quot;terminal&quot; className=&quot;form-control-static&quot;&amp;gt;Terminal：&amp;lt;/label&amp;gt;
                &amp;lt;BasicSelect
                    &amp;lt;!-- option数据 --&amp;gt;
                    optionData={terminalArr}
                    &amp;lt;!-- 引用的config里的数据的字段名（不是所有数据都是val,key） --&amp;gt;
                    optKey=&quot;key&quot;
                    optVal=&quot;val&quot;
                    &amp;lt;!-- 将上层组件获取到的formData.terminal传递给BasicSelect --&amp;gt;
                    defaultVal={this.props.terminal}
                    &amp;lt;!-- select name --&amp;gt;
                    nameText=&quot;terminal&quot;
                    &amp;lt;!-- change方法 --&amp;gt;
                    changeHandler={this.changeTerminalHandler}
                &amp;gt;&amp;lt;/BasicSelect&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最底层的组件：为了能够最大程度复用，所有文字内容都避免写死而是以变量（参考上一段代码html注释）传入。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var BasicSelect = React.createClass({
render: function () {
        // option内容
        var optionContent;
        // option html字段
        var optKey = this.props.optKey;
        // option value字段
        var optVal = this.props.optVal;

        // 遍历optionData的值（此处是terminalArr），返回所有option html代码
        optionContent = this.props.optionData.map(function (item) {
            return (
                &amp;lt;option value={item[optVal]}&amp;gt;{item[optKey]}&amp;lt;/option&amp;gt;
            );
        });

        // select
        return (
            &amp;lt;select 
                className=&quot;form-control&quot;
                defaultValue={this.props.defaultVal}
                name={this.props.nameText}
                onChange={this.props.changeHandler}
            &amp;gt;
                &amp;lt;option value=&quot;&quot;&amp;gt;全部&amp;lt;/option&amp;gt;
                {optionContent}
            &amp;lt;/select&amp;gt;
        );
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;exampleactionsjs&quot;&gt;ExampleActions.js&lt;/h2&gt;

&lt;p&gt;Dispatcher注册一个action，把这个action分发给example_set_terminal。&lt;/p&gt;

&lt;p&gt;module.exports = new Dispatcher();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setTerminal: function (params) {
    // action -&amp;gt; dispatcher
    PlatformDispatcher.dispatch({
        actionType: &#39;example_set_terminal&#39;,
        item: params
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;examplestorejs&quot;&gt;ExampleStore.js&lt;/h2&gt;

&lt;p&gt;store响应dispatcher分发出来的action。接收example_set_terminal，调用具体set方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PlatformDispatcher.register(function (payload) {
    var actionType = payload.actionType;

    switch (actionType) {
    	...
        case &#39;example_set_terminal&#39;:
            // dispatcher -&amp;gt; store
            exampleStore.setTerminal(payload.item);
            break;
        ...
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用方法，改变store&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ExampleStore.prototype = assign({}, EventEmitter.prototype, {

    ...

    // store -&amp;gt; view
    setTerminal: function (params) {
        // 这部分里，每当params被修改，queryObj就会被更新，相应的，
        // Example.js部分顶级组件接收的formData也会更新，继而更新所有组件中的数据。
        this.queryObj.terminal = params.terminal;
        this.emit(&#39;change&#39;);
    },
    addChangeListener: function (action) {
        this.on(&#39;change&#39;, action);
    },
    removeChangeListener: function (action) {
        this.removeListener(&#39;change&#39;, action);
    },
    emitChange: function () {
        this.emit(&#39;change&#39;);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，一个flux下实现select组件的栗子就完成了，然而，如果要级联呢？怎么办？&lt;/p&gt;

&lt;h1 id=&quot;select-1&quot;&gt;select级联&lt;/h1&gt;

&lt;p&gt;比如我们要实现一级目录和二级目录的级联，数据结构是这样的：&lt;/p&gt;

&lt;h2 id=&quot;configjs-1&quot;&gt;config.js&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;dirs: [
    {children:[{dirName:&#39;xx&#39;,dirId:&#39;secondDir0&#39;},
    {dirName:&#39;xx&#39;,dirId:&#39;secondDir1&#39;},
    {dirName:&#39;xx&#39;,dirId:&#39;secondDir2&#39;},
    {dirName:&#39;xx&#39;,dirId:&#39;secondDir3&#39;},
    {dirName:&#39;xx&#39;,dirId:&#39;secondDir4&#39;},
    {dirName:&#39;xx&#39;,dirId:&#39;secondDir5&#39;},
    {dirName:&#39;xx&#39;,dirId:&#39;secondDir6&#39;},
    {dirName:&#39;xx&#39;,dirId:&#39;secondDir7&#39;},
    {dirName:&#39;xx&#39;,dirId:&#39;secondDir8&#39;}],dirName:&#39;情感&#39;,dirId:&#39;firstDir0&#39;},
    ...
    // first1...2...3...
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;examplejs-1&quot;&gt;Example.js&lt;/h1&gt;

&lt;p&gt;此时，ExampleForm组件之下，使用一个DirsContent组件，传入上层分发下来的数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;DirsContent firstDir={formData.firstDir}
    secondDir={formData.secondDir}
&amp;gt;
&amp;lt;/DirsContent&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实现DirsContent组件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var DirsContent = React.createClass({

    // 两个select的change方法，action、store中类似上面terminal的写法
    changeFirstDirHandler: function (e) {
        ExampleActions.setFirstDir({
            firstDir: e.target.value
        });
    },
    changeSecondDirHandler: function (e) {
        ExampleActions.setSecondDir({
            secondDir: e.target.value
        });
    },
    render: function () {
        var firstDir = this.props.firstDir;
        var secondDir = this.props.secondDir;
        // 二级目录select选项初始为空
        secondDirsArr = [];
        // 如果选择了一级目录
        if (firstDir) {
        	// 二级目录取对应的children字段的值（以firstDir0、firstDir1、firstDir2...最后一位的数字为索引）
            secondDirsArr = dirsArr[firstDir.split(&#39;Dir&#39;)[1]].children;
        }
        return (
            &amp;lt;div className=&quot;form-group&quot;&amp;gt;
                &amp;lt;div className=&quot;form-group&quot;&amp;gt;
                    &amp;lt;label htmlFor=&quot;&quot; className=&quot;form-control-static&quot;&amp;gt;一级目录：&amp;lt;/label&amp;gt;
                    &amp;lt;BasicSelect
                    	&amp;lt;!-- 一级目录的数据，可以直接从config中获取 --&amp;gt;
                        optionData={dirsArr}
                        optKey=&quot;dirName&quot;
                        optVal=&quot;dirId&quot;
                        changeHandler={this.changeFirstDirHandler}
                        nameText=&quot;firstDir&quot;
                        defaultVal={firstDir}
                    &amp;gt;&amp;lt;/BasicSelect&amp;gt;
                &amp;lt;/div&amp;gt;

                &amp;lt;div className=&quot;form-group&quot;&amp;gt;
                    &amp;lt;label htmlFor=&quot;&quot; className=&quot;form-control-static&quot;&amp;gt;二级目录：&amp;lt;/label&amp;gt;
                    &amp;lt;BasicSelect
                    	&amp;lt;!-- 二级目录的数据，为render方法中计算出来的数据 --&amp;gt;
                        optionData={secondDirsArr}
                        optKey=&quot;dirName&quot;
                        optVal=&quot;dirId&quot;
                        defaultVal={secondDir}
                        nameText=&quot;secondDir&quot;
                        changeHandler={this.changeSecondDirHandler}
                    &amp;gt;&amp;lt;/BasicSelect&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section&quot;&gt;补充&lt;/h1&gt;

&lt;p&gt;到现在为止，写了五个大同小异的查询数据模块，猿生第一次写这么多的js代码（用了React不得不写这么多啊…），从开始的迷茫到逐渐拨开云雾见到彩虹，感谢&lt;a href=&quot;http://yansm.github.io/fromone&quot;&gt;三木君&lt;/a&gt;耐心的帮助和清晰的讲解。学习一种新的东西，或许，可以先上手再理解…&lt;/p&gt;
</description>
        <pubDate>Tue, 25 Aug 2015 14:03:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/flux/2015/08/25/react-flux-data-flow.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/flux/2015/08/25/react-flux-data-flow.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
        <category>flux</category>
        
      </item>
    
      <item>
        <title>bootstrap-select.js使用ajax get到的option数据</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;第一次用到，搜了很多博文都没用，一篇抄一篇而且整得特复杂…还是官方文档比较给力，然而最近红杏什么的都没法用了，代理jquery到国内cdn后才能正确显示效果，非常之坑…有些东西遮遮掩掩真的有用吗？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://silviomoreto.github.io/bootstrap-select/&quot;&gt;bootstrap-select.js官方文档&lt;/a&gt;&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;html：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;select class=&quot;form-control selectpicker&quot;  data-live-search=&quot;true&quot;&amp;gt;
	...
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js部分：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.ajax({
	// get请求地址
    	url: basePath,
    	dataType: &quot;json&quot;,
    	success: function (data) {
	    	var optArr = [];
	        for (var i = 0; i &amp;lt; data.length; i++) {
	            $(&#39;.selectpicker&#39;).append(&quot;&amp;lt;option value=&quot; + data[i].userName + &quot;&amp;gt;&quot; + data[i].userName + &quot;&amp;lt;/option&amp;gt;&quot;);
	        }

	        // 缺一不可
	        $(&#39;#adeName&#39;).selectpicker(&#39;refresh&#39;);
	        $(&#39;#adeName&#39;).selectpicker(&#39;render&#39;);
    }
});
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 25 Aug 2015 11:38:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/bootstrap/js/2015/08/25/bootstrap-select-with-ajax-data.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/bootstrap/js/2015/08/25/bootstrap-select-with-ajax-data.html</guid>
        
        
        <category>bootstrap</category>
        
        <category>js</category>
        
      </item>
    
  </channel>
</rss>
