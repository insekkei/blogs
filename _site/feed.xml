<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>web前端学习笔记</title>
    <description>绿螘新醅酒，红泥小火炉。&lt;br&gt;晚来天欲雪，能饮一杯无？
</description>
    <link>http://insekkei.com/blogs//blogs/</link>
    <atom:link href="http://insekkei.com/blogs//blogs/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 25 Aug 2015 15:50:06 +0800</pubDate>
    <lastBuildDate>Tue, 25 Aug 2015 15:50:06 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>react&amp;flux之BasicSelect组件实现</title>
        <description>&lt;p&gt;应工作需求，用到flux，为了解react设计思想及其flux强调的数据流，查找了各种在线资料，终于可以开工了。然而编码的时候时常产生一种怀疑：我真的是一个前端？&lt;/p&gt;

&lt;h1 id=&quot;react&quot;&gt;React&lt;/h1&gt;

&lt;p&gt;对于react，我是从&lt;a href=&quot;http://facebook.github.io/react/docs/getting-started.html&quot;&gt;这里&lt;/a&gt;开始了解的，然而这儿仅仅能了解到react的语法。&lt;/p&gt;

&lt;p&gt;对于习惯了html＋css＋js文件的我来说，乍一看到react的代码，第一反应是：html写在js中？这不就是前端一直强调的“结构、样式、行为分离”思想的反面教材吗？不能再颠覆啊！我感到无所适从。&lt;/p&gt;

&lt;p&gt;于是，我想应该先了解下react的设计思想，因此，我跳过了&lt;a href=&quot;http://facebook.github.io/react/docs/tutorial.html&quot;&gt;Tudorial&lt;/a&gt;，从&lt;a href=&quot;http://facebook.github.io/react/docs/thinking-in-react.html&quot;&gt;Thinking in React&lt;/a&gt;开始看起。&lt;/p&gt;

&lt;p&gt;在&lt;a href=&quot;http://facebook.github.io/react/docs/thinking-in-react.html&quot;&gt;Thinking in React&lt;/a&gt;页面我看到了一个很实用的栗子，然后快速地抓住了使用react编码的两个关键字：拆分、组件复用。&lt;/p&gt;

&lt;p&gt;更多关于“理解react设计思想”的文章，可以在许多知名博客中搜索到，文码并茂，看多了就理解了…&lt;/p&gt;

&lt;h1 id=&quot;flux&quot;&gt;flux&lt;/h1&gt;

&lt;p&gt;什么是flux？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;It’s more of a pattern rather than a formal framework.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;与angular双向数据绑定不同，它的数据流向永远是单向的，因此带来的好处是：我不必思考当前数据应该传递给谁。&lt;/p&gt;

&lt;p&gt;在flux中，view和controller是一体的，同时它增加的两层内容：dispatcher和stores，前者负责创建actions，然后将actions按照名称（&lt;code&gt;actionType&lt;/code&gt;）分发给stores，stores中对数据进行修改，触发一些change相关的方法，将改动渲染到view层（一般先是最高层级的组件收到新的数据，再把这些数据传递到子组件中）。简单说就是：&lt;/p&gt;

&lt;p&gt;Action -&amp;gt; Dispatcher -&amp;gt; Store -&amp;gt; View…&lt;/p&gt;

&lt;p&gt;实战总是比理论让人理解得更加深刻，这是当年学习依赖注入、控制翻转时得到的结论。于是在写了几个查询数据的模块之后，将一点心得在这里记录下来，方便以后查看。&lt;/p&gt;

&lt;h1 id=&quot;select&quot;&gt;一个select组件实例&lt;/h1&gt;

&lt;p&gt;这里将通过一个select组件的实现过程描述flux的数据流。&lt;/p&gt;

&lt;h2 id=&quot;configjs&quot;&gt;静态数据：config.js&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;terminalArr: [
    {
        key: &#39;x&#39;,
        val: &#39;0&#39;
    },
    {
        key: &#39;xx&#39;,
        val: &#39;1&#39;
    },
    {
        key: &#39;xxx&#39;,
        val: &#39;2&#39;
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;examplejs&quot;&gt;Example.js&lt;/h2&gt;

&lt;p&gt;顶层view组件，监测stores变化，并将新的queryObj传递给组件的formData属性，由顶级组件向下分发数据。&lt;/p&gt;

&lt;pre&gt;var Example = React.createClass({
	
    componentDidMount: function () {
        exampleStore.addChangeListener(this._change);

        if (this.isMounted()) {
            exampleStore.loadData();
        }
    },
    componentWillUnmount: function () {
        exampleStore.removeChangeListener(this._change);
    },
    _change: function () {
        this.setState(exampleStore.queryObj);
    },
    render: function () {
        return (
        	&amp;lt;div&amp;gt;
        		...
                &amp;lt;ExampleForm formData={this.state.queryObj}/&amp;gt;
                ...
            &amp;lt;/div&amp;gt;
        );
    }
});
&lt;/pre&gt;

&lt;p&gt;中间组件，从formData中取出特定数据，传递给再下游的组件作为属性（props）值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var ExampleForm = React.createClass({
    render: function () {
        var formData = this.props.formData;
        return (
            &amp;lt;form&amp;gt;
                ...
                &amp;lt;TerminalsSelect terminal={formData.terminal}&amp;gt;&amp;lt;/Terminals&amp;gt;
                ...
            &amp;lt;/form&amp;gt;
        );
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续向下，当select change时，调用action中的方法，其中select使用了已经定义好的BasicSelect组件，因此需要传递一些参数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var TerminalsSelect =  React.createClass({
    changeTerminalHandler: function (e) {
    	// view -&amp;gt; action
        ExampleActions.setTerminal({
            terminal: e.target.value
        });
    },
    render: function () {
        return (
            &amp;lt;div className=&quot;form-group&quot;&amp;gt;
                &amp;lt;label htmlFor=&quot;terminal&quot; className=&quot;form-control-static&quot;&amp;gt;Terminal：&amp;lt;/label&amp;gt;
                &amp;lt;BasicSelect
                    &amp;lt;!-- option数据 --&amp;gt;
                    optionData={terminalArr}
                    &amp;lt;!-- 引用的config里的数据的字段名（不是所有数据都是val,key） --&amp;gt;
                    optKey=&quot;key&quot;
                    optVal=&quot;val&quot;
                    &amp;lt;!-- 将上层组件获取到的formData.terminal传递给BasicSelect --&amp;gt;
                    defaultVal={this.props.terminal}
                    &amp;lt;!-- select name --&amp;gt;
                    nameText=&quot;terminal&quot;
                    &amp;lt;!-- change方法 --&amp;gt;
                    changeHandler={this.changeTerminalHandler}
                &amp;gt;&amp;lt;/BasicSelect&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最底层的组件：为了能够最大程度复用，所有文字内容都避免写死而是以变量（参考上一段代码注释）传入。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var BasicSelect = React.createClass({
render: function () {
        // option内容
        var optionContent;
        // option html字段
        var optKey = this.props.optKey;
        // option value字段
        var optVal = this.props.optVal;

        // 遍历optionData的值（此处是terminalArr），返回所有option html代码
        optionContent = this.props.optionData.map(function (item) {
            return (
                &amp;lt;option value={item[optVal]}&amp;gt;{item[optKey]}&amp;lt;/option&amp;gt;
            );
        });

        // select
        return (
            &amp;lt;select 
                className=&quot;form-control&quot;
                defaultValue={this.props.defaultVal}
                name={this.props.nameText}
                onChange={this.props.changeHandler}
            &amp;gt;
                &amp;lt;option value=&quot;&quot;&amp;gt;全部&amp;lt;/option&amp;gt;
                {optionContent}
            &amp;lt;/select&amp;gt;
        );
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;exampleactionsjs&quot;&gt;ExampleActions.js&lt;/h2&gt;

&lt;p&gt;Dispatcher创建一个action。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setTerminal: function (params) {
    // action -&amp;gt; dispatcher
    PlatformDispatcher.dispatch({
        actionType: &#39;example_set_terminal&#39;,
        item: params
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;examplestorejs&quot;&gt;ExampleStore.js&lt;/h2&gt;

&lt;p&gt;处理actionType，调用具体方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PlatformDispatcher.register(function (payload) {
    var actionType = payload.actionType;

    switch (actionType) {
    	...
        case &#39;example_set_terminal&#39;:
            // dispatcher -&amp;gt; store
            exampleStore.setTerminal(payload.item);
            break;
        ...
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的方法触发emit，使store改变，view重新渲染。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ExampleStore.prototype = assign({}, EventEmitter.prototype, {

    ...

    // store -&amp;gt; view
    setTerminal: function (params) {
        this.queryObj.terminal = params.terminal;
        this.emit(&#39;change&#39;);
    },
    addChangeListener: function (action) {
        this.on(&#39;change&#39;, action);
    },
    removeChangeListener: function (action) {
        this.removeListener(&#39;change&#39;, action);
    },
    emitChange: function () {
        this.emit(&#39;change&#39;);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，一个flux下实现select组件的栗子就完成了，然而，如果要级联呢？怎么办？&lt;/p&gt;

&lt;h1 id=&quot;select-1&quot;&gt;select级联&lt;/h1&gt;

&lt;p&gt;比如我们要实现一级目录和二级目录的级联，数据结构是这样的：&lt;/p&gt;

&lt;h2 id=&quot;configjs-1&quot;&gt;config.js&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;dirs: [
    {children:[{dirName:&#39;xx&#39;,dirId:&#39;secondDir0&#39;},
    {dirName:&#39;xx&#39;,dirId:&#39;secondDir1&#39;},
    {dirName:&#39;xx&#39;,dirId:&#39;secondDir2&#39;},
    {dirName:&#39;xx&#39;,dirId:&#39;secondDir3&#39;},
    {dirName:&#39;xx&#39;,dirId:&#39;secondDir4&#39;},
    {dirName:&#39;xx&#39;,dirId:&#39;secondDir5&#39;},
    {dirName:&#39;xx&#39;,dirId:&#39;secondDir6&#39;},
    {dirName:&#39;xx&#39;,dirId:&#39;secondDir7&#39;},
    {dirName:&#39;xx&#39;,dirId:&#39;secondDir8&#39;}],dirName:&#39;情感&#39;,dirId:&#39;firstDir0&#39;},
    ...
    // first1...2...3...
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;examplejs-1&quot;&gt;Example.js&lt;/h1&gt;

&lt;p&gt;此时，ExampleForm组件之下，使用一个DirsContent组件，传入上层分发下来的数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;DirsContent firstDir={formData.firstDir}
    secondDir={formData.secondDir}
&amp;gt;
&amp;lt;/DirsContent&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实现DirsContent组件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var DirsContent = React.createClass({

    // 两个select的change方法，action、store中类似上面terminal的写法
    changeFirstDirHandler: function (e) {
        ExampleActions.setFirstDir({
            firstDir: e.target.value
        });
    },
    changeSecondDirHandler: function (e) {
        ExampleActions.setSecondDir({
            secondDir: e.target.value
        });
    },
    render: function () {
        var firstDir = this.props.firstDir;
        var secondDir = this.props.secondDir;
        // 二级目录select选项初始为空
        secondDirsArr = [];
        // 如果选择了一级目录
        if (firstDir) {
        	// 二级目录取对应的children字段的值（以firstDir0、firstDir1、firstDir2...最后一位的数字为索引）
            secondDirsArr = dirsArr[firstDir.split(&#39;Dir&#39;)[1]].children;
        }
        return (
            &amp;lt;div className=&quot;form-group&quot;&amp;gt;
                &amp;lt;div className=&quot;form-group&quot;&amp;gt;
                    &amp;lt;label htmlFor=&quot;&quot; className=&quot;form-control-static&quot;&amp;gt;一级目录：&amp;lt;/label&amp;gt;
                    &amp;lt;BasicSelect
                    	&amp;lt;!-- 一级目录的数据，可以直接从config中获取 --&amp;gt;
                        optionData={dirsArr}
                        optKey=&quot;dirName&quot;
                        optVal=&quot;dirId&quot;
                        changeHandler={this.changeFirstDirHandler}
                        nameText=&quot;firstDir&quot;
                        defaultVal={firstDir}
                    &amp;gt;&amp;lt;/BasicSelect&amp;gt;
                &amp;lt;/div&amp;gt;

                &amp;lt;div className=&quot;form-group&quot;&amp;gt;
                    &amp;lt;label htmlFor=&quot;&quot; className=&quot;form-control-static&quot;&amp;gt;二级目录：&amp;lt;/label&amp;gt;
                    &amp;lt;BasicSelect
                    	&amp;tl;!-- 二级目录的数据，为render方法中计算出来的数据 --&amp;gt;
                        optionData={secondDirsArr}
                        optKey=&quot;dirName&quot;
                        optVal=&quot;dirId&quot;
                        defaultVal={secondDir}
                        nameText=&quot;secondDir&quot;
                        changeHandler={this.changeSecondDirHandler}
                    &amp;gt;&amp;lt;/BasicSelect&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section&quot;&gt;补充&lt;/h1&gt;

&lt;p&gt;到现在为止，写了五个大同小异的查询数据模块，猿生第一次写这么多的js代码（用了React不得不写这么多啊…），从开始的迷茫到逐渐拨开云雾见到彩虹，感谢&lt;a href=&quot;http://yansm.github.io/fromone&quot;&gt;三木君&lt;/a&gt;耐心的帮助和清晰的讲解。学习一种新的东西，或许，可以先上手再理解…&lt;/p&gt;
</description>
        <pubDate>Tue, 25 Aug 2015 14:03:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/flux/2015/08/25/react&flux-data-flow.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/flux/2015/08/25/react&flux-data-flow.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
        <category>flux</category>
        
      </item>
    
      <item>
        <title>bootstrap-select.js使用ajax get到的option数据</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;第一次用到，搜了很多博文都没用，一篇抄一篇而且整得特复杂…还是官方文档比较给力，然而最近红杏什么的都没法用了，代理jquery到国内cdn后才能正确显示效果，非常之坑…有些东西遮遮掩掩真的有用吗？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://silviomoreto.github.io/bootstrap-select/&quot;&gt;bootstrap-select.js官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;html：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;select class=&quot;form-control selectpicker&quot;  data-live-search=&quot;true&quot;&amp;gt;
	...
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js部分：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.ajax({
	// get请求地址
    	url: basePath,
    	dataType: &quot;json&quot;,
    	success: function (data) {
	    	var optArr = [];
	        for (var i = 0; i &amp;lt; data.length; i++) {
	            $(&#39;.selectpicker&#39;).append(&quot;&amp;lt;option value=&quot; + data[i].userName + &quot;&amp;gt;&quot; + data[i].userName + &quot;&amp;lt;/option&amp;gt;&quot;);
	        }

	        // 缺一不可
	        $(&#39;#adeName&#39;).selectpicker(&#39;refresh&#39;);
	        $(&#39;#adeName&#39;).selectpicker(&#39;render&#39;);
    }
});
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 25 Aug 2015 11:38:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/bootstrap/js/2015/08/25/bootstrap-select-with-ajax-data.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/bootstrap/js/2015/08/25/bootstrap-select-with-ajax-data.html</guid>
        
        
        <category>bootstrap</category>
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>angularjs结合localstorage完成一个简单的备忘录</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;学习一种新的框架真的是痛并快乐着…而当确定了一个清晰的目标，向着这个目标努力时，成就感带来的快感将远大于茫然不解时的痛苦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;——&amp;gt;&lt;a href=&quot;http://insekkei.com/todolist&quot;&gt;预览效果&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;准备工作&lt;/h1&gt;

&lt;p&gt;用bower安装需要的js：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bower install angular
bower install angular-local-storage
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;html中引用bower_components下对应的js文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;js/angular.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;js/angular-local-storage.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：npm也可以，直接下载相应js文件或者用cdn也是ok的…&lt;/p&gt;

&lt;h1 id=&quot;angularjs-directivehttpinsekkeicomblogsangularjs20150709angularjs-e8afade6b395e6b585e69e90htmlindexhtml&quot;&gt;通过&lt;a href=&quot;http://insekkei.com/blogs/angular/js/2015/07/09/angular.js-%E8%AF%AD%E6%B3%95%E6%B5%85%E6%9E%90.html&quot;&gt;angularjs Directive&lt;/a&gt;扩展index.html&lt;/h1&gt;

&lt;h2 id=&quot;angular&quot;&gt;angular接管整个页面：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html ng-app=&quot;todoApp&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;bodytodocontroller&quot;&gt;body中的数据由&lt;code&gt;TodoController&lt;/code&gt;来控制：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body ng-controller=&quot;TodoController&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;form&quot;&gt;添加备忘的form：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form ng-submit=&quot;add()&quot;&amp;gt;
	&amp;lt;input placeholder=&quot;What you want to do...&quot; type=&quot;text&quot; ng-model=&quot;todoItem&quot; name=&quot;totoItem&quot;&amp;gt;
	&amp;lt;input type=&quot;submit&quot; id=&quot;submit&quot; value=&quot;add&quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;form&lt;/code&gt;提交表单时（&lt;code&gt;ng-submit&lt;/code&gt;）执行&lt;code&gt;add()&lt;/code&gt;方法，输入框的内容通过&lt;code&gt;ng-model&lt;/code&gt;与&lt;code&gt;todoItem&lt;/code&gt;关联，使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...$scope.todoItem...&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;list&quot;&gt;添加备忘list&lt;/h2&gt;

&lt;p&gt;每条备忘中包含的信息：内容&lt;code&gt;content&lt;/code&gt;、日期&lt;code&gt;creDate&lt;/code&gt;、删除按钮。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
	&amp;lt;li ng-repeat=&quot;todo in todoList&quot;&amp;gt;
		&amp;lt;time&amp;gt;{ {todo.creDate} }&amp;lt;/time&amp;gt;
		&amp;lt;input type=&quot;text&quot; ng-model=&quot;todo.content&quot;&amp;gt;
		&amp;lt;span&amp;gt;{ {todo.content} }&amp;lt;/span&amp;gt;
		&amp;lt;input type=&quot;button&quot; value=&quot;remove&quot; ng-click=&quot;remove($index)&quot;&amp;gt;
	&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ng-repeat&lt;/code&gt;用来循环输出每一条备忘，&lt;code&gt;ng-model&lt;/code&gt;指定当前&lt;code&gt;input&lt;/code&gt;的值即备忘内容&lt;code&gt;content&lt;/code&gt;，&lt;code&gt;ng-click&lt;/code&gt;将&lt;code&gt;remove&lt;/code&gt;按钮和&lt;code&gt;remove(index)&lt;/code&gt;方法关联。&lt;/p&gt;

&lt;h1 id=&quot;todojs&quot;&gt;todo.js&lt;/h1&gt;

&lt;p&gt;声明app&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var todoApp=angular.module(&#39;todoApp&#39;,[]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义controller&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;todoApp.controller(&#39;TodoController&#39;, function($scope) {
	...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义todoList&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$scope.todoList = [];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;add方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$scope.add = function() {
	// 如果输入框有值
    if ($scope.todoItem) {
    	// 定义一个空对象
        var todoInfo = {};
        // 对象的三个属性：时间为创建时时间
        todoInfo.creDate = new Date().getMonth() + &#39;/&#39; + new Date().getDate();
        todoInfo.content = $scope.todoItem;
        todoInfo.status = &#39;active&#39;;

        // 将todoInfo添加到todoList头部
        $scope.todoList.unshift(todoInfo);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;remove方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 删除index位置开始的1个数组元素
$scope.remove = function(index) {
    $scope.todoList.splice(index, 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;todojslocalstorage&quot;&gt;改造todo.js，使用localstorage持久化&lt;/h1&gt;

&lt;p&gt;两种思路：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分别在&lt;code&gt;$scope.todoList&lt;/code&gt;查询、添加、删除时同步操作&lt;code&gt;localstorage&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;监听&lt;code&gt;$scope.todoList&lt;/code&gt;，当它改变时把&lt;code&gt;$scope.todoList&lt;/code&gt;赋值给&lt;code&gt;localstorage&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一种方法明显麻烦很多，但当时不知道&lt;code&gt;$scope.$watch&lt;/code&gt;可以做到监听…这里使用&lt;code&gt;$scope.$watch&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;添加localstorage模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var todoApp=angular.module(&#39;todoApp&#39;,[&#39;LocalStorageModule&#39;]);
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;controller上传入服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;todoApp.controller(&#39;TodoController&#39;, function($scope, localStorageService) {
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从localstorage中get数据，如果不为空，赋值给&lt;code&gt;$scope.todoList&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var todoInStore = localStorageService.get(&#39;todoList&#39;);
$scope.todoList = todoInStore || [];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;监听$scope.todoList，当它改变时，使用localstorage的&lt;code&gt;set()&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$scope.$watch(&#39;todoList&#39;, function () {
    localStorageService.set(&#39;todoList&#39;, $scope.todoList);
}, true);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;over&quot;&gt;over&lt;/h1&gt;

&lt;p&gt;这样就实现了一个简版的备忘录，只要缓存没有被清理，备忘会一直在。&lt;/p&gt;

&lt;p&gt;另外angular local storage还提供了一些方法供开发者使用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;remove(key)：匹配key删除localStorage条目&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;clearAll()：删除全部localStorage&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;isSupported：检测浏览器是否支持localStorage&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cookie：操作cookie的方法同localStorage，包含&lt;code&gt;set&lt;/code&gt;、&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;remove&lt;/code&gt;、&lt;code&gt;clearAll&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 05 Aug 2015 14:59:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/angularjs/js/2015/08/05/angularjs-localstorage.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/angularjs/js/2015/08/05/angularjs-localstorage.html</guid>
        
        
        <category>angularjs</category>
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>jquery中操作radio和checkbox</title>
        <description>&lt;h1 id=&quot;jqueryradiocheckbox&quot;&gt;jquery判断radio或者checkbox是否被选中&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;// 返回true or false
$(&#39;selector&#39;).is(&#39;:checked&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;jqueryradiocheckbox-1&quot;&gt;jquery操作radio或者checkbox使它们被选中&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;//For versions higher than 1.6, use:
$(&#39;#radio_1&#39;).prop(&#39;checked&#39;, true)
//For versions of jQuery prior to 1.6, use:
$(&#39;#radio_1&#39;).attr(&#39;checked&#39;, &#39;checked&#39;);
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 29 Jul 2015 17:50:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/jquery/js/2015/07/29/jquery%E4%B9%8Bradio%20&%20checkbox.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/jquery/js/2015/07/29/jquery%E4%B9%8Bradio%20&%20checkbox.html</guid>
        
        
        <category>jquery</category>
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>angular.js语法浅析</title>
        <description>&lt;p&gt;声明：本文所有的双花括号，为了防止被jekyll当作本身变量编译，都在括号之间增加了空格，原本应该是没有空格的。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;概念&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;AngularJS is a structural framework for dynamic web apps.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;directive&quot;&gt;Directive&lt;/h2&gt;

&lt;p&gt;扩展html，给html添加声明语句，以便实现自己的需求。对于页面中html元素以&lt;code&gt;ng&lt;/code&gt;为前缀的属性名称，&lt;code&gt;ng&lt;/code&gt;是angular的命名空间，&lt;code&gt;-&lt;/code&gt;后面的部分都是Directive。常用的如：&lt;code&gt;ng-app&lt;/code&gt;，&lt;code&gt;ng-cotroller&lt;/code&gt;，&lt;code&gt;ng-repeat&lt;/code&gt;，&lt;code&gt;ng-model&lt;/code&gt;，&lt;code&gt;ng-click&lt;/code&gt;等等。&lt;/p&gt;

&lt;p&gt;另外，还有一些关于表单的directive，如&lt;code&gt;input[email]&lt;/code&gt;，&lt;code&gt;input[url]&lt;/code&gt;等。&lt;/p&gt;

&lt;p&gt;有的时候，直接写入html的方式并不能满足我们处理浏览器事件或者修改dom的需求，于是我们需要使用directive方法来改变view，用法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.directive(&#39;directiveName&#39;, directiveFactoryFunction);&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;scope&quot;&gt;scope&lt;/h2&gt;

&lt;p&gt;为把model里的data暴露给view，我们需要将$scope对象传给controller。$scope是controller与view之间的纽带。而&lt;code&gt;ng-controller&lt;/code&gt;能够负责的dom范围，就是controller中$scope的有效区域（正确传递数据，传递正确的数据）。&lt;/p&gt;

&lt;h2 id=&quot;service&quot;&gt;service&lt;/h2&gt;

&lt;p&gt;services都是单例的（不知可否参考设计模式中的单例模式去理解），angular中的service有：&lt;code&gt;$location&lt;/code&gt;，&lt;code&gt;route&lt;/code&gt;，&lt;code&gt;$http&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;当一个app中有一堆controller，其中一些controller实现类似的逻辑（如一个查询功能：发送服务器请求－解析服务器返回的内容存入对象－将对象添加到$scope以显示到view），这时我们就可以定义一个那些controller共用的service，这样做的好处是：1、可以在controller中共享它们，从而减少重复的代码，方便阅读；2、需要的话，多个controller之间能够进行交流，分享状态…&lt;/p&gt;

&lt;p&gt;三种方式去创建一个service：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Services&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;语法: module.service( ‘serviceName’, function );&lt;/p&gt;

&lt;p&gt;用法：不可配置，内部通过new实例化对象，给this添加属性，然后返回this。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Factories&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;语法: module.factory( ‘factoryName’, function );&lt;/p&gt;

&lt;p&gt;用法：不可配置，内部直接创建一个对象，为它添加属性，然后返回这个对象。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Providers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;语法: module.provider( ‘providerName’, function );&lt;/p&gt;

&lt;p&gt;用法：可配置，内部通过$get方法返回一个实例对象。&lt;/p&gt;

&lt;p&gt;备注：controller使用serviceName／factoryName／providerName作为参数，通过angular的依赖注入特性获取结果。&lt;/p&gt;

&lt;h2 id=&quot;filter&quot;&gt;filter&lt;/h2&gt;

&lt;p&gt;声明data被显示给用户的格式，语法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; { { expression | filterName : parameter1 : ...parameterN } }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如&lt;code&gt;{ {12.9 | currency | number:0 } }&lt;/code&gt;显示为&lt;code&gt;$13&lt;/code&gt;。常用的filter还有&lt;code&gt;json&lt;/code&gt;，&lt;code&gt;lowercase&lt;/code&gt;，&lt;code&gt;orderBy&lt;/code&gt;等等。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;filtername&lt;/code&gt;也可以是自定义的处理数据（转化格式）方法的方法名。&lt;/p&gt;

&lt;h2 id=&quot;routelocation&quot;&gt;route&amp;amp;location&lt;/h2&gt;

&lt;p&gt;Ajax应用比较明显的缺点就是，window不能记住页面（局部）url，虽然有一系列解决方案（iframe，onhashchange，pushState结合location.href等），但需要做很多额外的工作。&lt;/p&gt;

&lt;p&gt;angularjs中，可以通过&lt;code&gt;$route&lt;/code&gt;和&lt;code&gt;$location&lt;/code&gt;来改变view（选择加载哪一个view）。如下面这段代码，通过调用&lt;code&gt;$routeProvider&lt;/code&gt;的方法创建route，当发现url变成某一个&lt;code&gt;url&lt;/code&gt;时，&lt;code&gt;aController&lt;/code&gt;关联的&lt;code&gt;ng-controller&lt;/code&gt;元素将load &lt;code&gt;/path/to/tempate&lt;/code&gt;里的模板。如果没有找到匹配的模板，执行&lt;code&gt;otherwise&lt;/code&gt;中的代码。（使用代码时需要web服务器）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.config(function($routeProvider) {
    $routeProvider.
    when(&#39;url&#39;, {controller:aController, templateUrl:&#39;/path/to/tempate&#39;}). 
    when(...other mappings for your app...).
    ...
    otherwise(...what to do if nothing else matches...);
)};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每一个template里只有局部代码，链接&lt;code&gt;a&lt;/code&gt;元素的&lt;code&gt;href&lt;/code&gt;与&lt;code&gt;route&lt;/code&gt;中的&lt;code&gt;url&lt;/code&gt;相关，index.html模板通过&lt;code&gt;ng-view&lt;/code&gt;元素来标识哪部分是需要局部加载上来的。&lt;/p&gt;

&lt;h2 id=&quot;http&quot;&gt;http&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;$http&lt;/code&gt;是一个service，angular提供了一些方法使我们可以方便地从服务器获取数据。&lt;/p&gt;

&lt;p&gt;比如一个从server获取数据并且显示到view的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function ShoppingController($scope, $http) { 
    $http.get(&#39;/products&#39;).success(function(data, status, headers, config) {
        $scope.items = data;
    });
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;html中值为&lt;code&gt;ShoppingController&lt;/code&gt;的&lt;code&gt;ng-controller&lt;/code&gt;里面就能通过&lt;code&gt;ng-repeat&lt;/code&gt;方式动态创建html，并且使用&lt;code&gt;item&lt;/code&gt;每一项的数据。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;优势&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;angularjs扩展了html，缓解了编写ajax应用的痛苦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;mvc&quot;&gt;MVC&lt;/h2&gt;

&lt;p&gt;Model包含app当前状态的数据，用对象来定义如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var someText = &#39;&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;View显示数据，在dom中这样展示：&lt;code&gt;{ {someText} }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Controller用来关联M和V，使用&lt;code&gt;$scope&lt;/code&gt;对象来传递／操作Model，创建方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function TextController($scope) { 
   $scope.someText = someText;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MVC中，焦点应该被放在Model上：应该定义怎样的对象？怎样从服务器接收和保存对象？等等，花些时间考虑这些问题。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;数据绑定&lt;/h2&gt;

&lt;p&gt;利用数据绑定特性，以非常精短的代码，在操作数据的同时实现页面的自动局部刷新。&lt;/p&gt;

&lt;p&gt;如下的例子中，当点击button，items数组的对应位置（index）首先被删除，由于div的数量由items决定（ng-repeat），因此当对数组items的删除操作完成时，dom也随之刷新。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div ng-repeat=&#39;item in items&#39;&amp;gt;
    &amp;lt;span&amp;gt;{ {item.title} }&amp;lt;/span&amp;gt;
    &amp;lt;input ng-model=&#39;item.quantity&#39;&amp;gt;
    &amp;lt;span&amp;gt;{ {item.price | currency} }&amp;lt;/span&amp;gt; 
    &amp;lt;span&amp;gt;{ {item.price * item.quantity | currency} }&amp;lt;/span&amp;gt; 
    &amp;lt;button ng-click=&quot;remove($index)&quot;&amp;gt;Remove&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;

function CartController($scope) { 
    $scope.items = [
        {title: &#39;Paint pots&#39;, quantity: 8, price: 3.95},
        {title: &#39;Polka dots&#39;, quantity: 17, price: 12.95},
        {title: &#39;Pebbles&#39;, quantity: 5, price: 6.95}
    ];
    $scope.remove = function(index) { 
        $scope.items.splice(index, 1);
    } 
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;依赖注入&lt;/h2&gt;

&lt;p&gt;angular要求我们遵循编码规则，按照规定去写代码，使用规定的参数名，这样来自动获取需要的内容。&lt;/p&gt;

&lt;p&gt;比如controller中通过serviceName来获取service的返回值。&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jul 2015 10:22:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/angular/js/2015/07/09/angular.js-%E8%AF%AD%E6%B3%95%E6%B5%85%E6%9E%90.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/angular/js/2015/07/09/angular.js-%E8%AF%AD%E6%B3%95%E6%B5%85%E6%9E%90.html</guid>
        
        
        <category>angular</category>
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>新手接触gulp</title>
        <description>&lt;p&gt;因工作需要第一次接触到&lt;a href=&quot;http://gulpjs.com/&quot;&gt;gulp&lt;/a&gt;（在前端混真的很惭愧…），在此记录下对gulp的认识。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;概念：&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Gulp.js是一个基于node.js的自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;全局安装：&lt;/h1&gt;

&lt;p&gt;$ npm install –global gulp&lt;/p&gt;

&lt;h1 id=&quot;gulpfilejs&quot;&gt;gulpfile.js文件：&lt;/h1&gt;

&lt;p&gt;在项目的根目录下创建。默认任务（什么也不做）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var gulp = require(&#39;gulp&#39;);

gulp.task(&#39;default&#39;, function() {
  // place code for your default task here
});&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;gulp&quot;&gt;运行 gulp&lt;/h1&gt;

&lt;p&gt;$ gulp&lt;/p&gt;

&lt;h1 id=&quot;gulpapi&quot;&gt;来看看gulp的API！&lt;/h1&gt;

&lt;p&gt;分为四个大的部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;gulp.src：定义被操作的源文件（可用*来指定目录、文件类型）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gulp.task：定义任务，例如压缩、优化、编译等等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gulp.dest：在指定目录写入（执行任务后）生成的文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gulp.watch：当一个文件被修改时，执行某个任务&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;*简单来说就是：哪些文件（src）？进行怎样的操作（task）？结果怎么写入（dest）？&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;举个例子！&lt;/h1&gt;

&lt;p&gt;创建一个监听所有类型为less的文件的任务，当任何一个less文件被修改时，执行less-pro这个任务。*&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gulp.task(&#39;watch-less&#39;, function () {

    gulp.watch(&#39;less/*.less&#39;, [&#39;less-pro&#39;]);

});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;less-pro任务片段如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gulp.task(&#39;less-pro&#39;, function () {

	console.log(&#39;开始编译&#39;);

    //编译过程...

    console.log(&#39;结束编译&#39;);

	});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上watch less的例子中，执行：&lt;/p&gt;

&lt;p&gt;$ gulp watch-less&lt;/p&gt;

&lt;p&gt;就可以实现实时监控less文件改变并且进行编译的目的了。&lt;/p&gt;

&lt;h1 id=&quot;gulphttpgulpjscomplugins&quot;&gt;gulp有很多简洁而强大的&lt;a href=&quot;http://gulpjs.com/plugins/&quot;&gt;插件&lt;/a&gt;！&lt;/h1&gt;
</description>
        <pubDate>Sat, 04 Jul 2015 16:54:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/gulp/js/2015/07/04/%E6%96%B0%E6%89%8B%E6%8E%A5%E8%A7%A6gulp.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/gulp/js/2015/07/04/%E6%96%B0%E6%89%8B%E6%8E%A5%E8%A7%A6gulp.html</guid>
        
        
        <category>gulp</category>
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>js数组去重 及 计算字符串中字符的个数</title>
        <description>&lt;p&gt;1、数组去重。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;方法一：&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1,2,3,4,5,1,3,12,55,22];
function getArray(a){
	var obj = {},
	resultArray = [];
	for(var i=0;i&amp;lt;a.length;i++){
   		obj[a[i]]=a[i];
		console.log(obj);//纯数字时自带排序
	}
	for(var i in obj){
		resultArray.push(obj[i]);
	}
	console.log(resultArray);
}
getArray(arr);//[1, 2, 3, 4, 5, 12, 22, 55]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;方法二：不存储排序，只利用hash去重&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1,2,3,4,5,1,3,12,55,22];
function getArray2(a){
	var obj = {},
	resultArray = [];
	for(var i=0;i&amp;lt;a.length;i++){
		if(!obj[a[i]]){
			obj[a[i]]=true;     
			resultArray.push(a[i]);
		}
	}
	console.log(resultArray);
}
getArray2(arr);//[1, 2, 3, 4, 5, 12, 55, 22]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、给一个字符串，输出里面的字母分别出现的次数。&lt;/p&gt;

&lt;p&gt;将上题中的hash值改为计数器就可以了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var string = &quot;serdtfyghjhbuygfct&quot;;
function getCount(str){
	var obj = {},
	         a = str.split(&quot;&quot;); 
	for(var i=0;i&amp;lt;a.length;i++){
		if(!obj[a[i]]){
			obj[a[i]]=1;//发现是新的value
		}else{
			obj[a[i]]+=1;
		}
	}
	console.log(obj);
}
getCount(string);//Object {s: 1, e: 1, r: 1, d: 1, t: 2…}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 16 Jun 2015 12:00:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/js/function/2015/06/16/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E5%8F%8A%E8%AE%A1%E7%AE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AD%97%E7%AC%A6%E7%9A%84%E4%B8%AA%E6%95%B0.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/js/function/2015/06/16/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E5%8F%8A%E8%AE%A1%E7%AE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AD%97%E7%AC%A6%E7%9A%84%E4%B8%AA%E6%95%B0.html</guid>
        
        
        <category>js</category>
        
        <category>function</category>
        
      </item>
    
      <item>
        <title>Javascript反序输出字符串</title>
        <description>&lt;p&gt;这是一个我在至少4次web前端笔试或者面试中遇到过的题目，就这么一行字的题目，最近一次看到却还让我如遭五雷轰顶，罪过，罪过。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;解决方案一：&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;gt;&#39;abcd ed&#39;.split(&#39;&#39;).reverse().join(&#39;&#39;); 
&amp;lt;-&quot;de dcba&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果写成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;gt;&#39;abcd ed&#39;.split(&#39;&#39;).reverse().join(); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果会是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;&quot;-d,e, ,d,c,b,a&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意&lt;code&gt;join(seperator)&lt;/code&gt;方法是通过指定的字符连接数组所有元素，默认连接符是&lt;code&gt;.&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;解决方案二：&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;gt;&quot;abcd ed&quot;.split(&#39;&#39;).sort(function(a,b){return 1;}).join(&#39;&#39;);
&amp;lt;-&quot;de dcba&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sort(sortby)&lt;/code&gt;方法，如果没有sortby参数，返回数组按照字母顺序，即字符编码顺序进行排列。现在，按照&lt;code&gt;sort()&lt;/code&gt;方法的说明，return 1，也就是一个大于0的数，表示排序后的数组中a应该出现在b之后。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;解决方案三：&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;gt;str=&#39;abcd ed&#39;;Array.prototype.map.call(str,function(it, i){return str[str.length-i-1];}).join(&#39;&#39;);
&amp;lt;-&quot;de dcba&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对@yfwz100的这个方法我表示五体投地地膜拜Orz。
map()方法会给数组中的每个元素都按顺序调用一次 callback 函数。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;var numbers = [1, 4, 9]; 
&amp;gt;numbers.map(function(num) { return num * 2; });
&amp;lt;-[2, 8, 18]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方案三使用了&lt;code&gt;array.map(callback[, thisArg])&lt;/code&gt;，并且，字符串被当作数组来使用…，callback中第一个参数是数组中当前被传递的元素，这里即字符串中当前被传递的字符，第二个参数是当前被传递元素的索引，第三个参数是调用map方法的数组。
例1，获取每个字符串对应的ASCLL码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;Array.prototype.map.call(&quot;Hello World&quot;, function(x) { return x.charCodeAt(0); }) 
&amp;lt;-[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常情况下，map 方法中的 &lt;code&gt;callback&lt;/code&gt; 函数只需要接受一个参数，就是正在被遍历的数组元素本身。但这并不意味着 &lt;code&gt;map&lt;/code&gt; 只给 &lt;code&gt;callback&lt;/code&gt; 传了一个参数，第三个参数callback会忽视，但第二个参数&lt;code&gt;index&lt;/code&gt;会被使用。&lt;/p&gt;

&lt;p&gt;例2，进制数转换：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt);
&amp;lt;-[1, NaN, NaN]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例2中，&lt;code&gt;parseInt()&lt;/code&gt;方法有两个参数，&lt;code&gt;element&lt;/code&gt;和&lt;code&gt;进制数&lt;/code&gt;，于是它将&lt;code&gt;index&lt;/code&gt;视为了进制数。因此正确的方法应该是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;function returnInt(element){ return parseInt(element,10); }
&amp;gt;[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(returnInt);
&amp;lt;-[1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 16 Jun 2015 11:49:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/js/function/2015/06/16/Javascript-%E5%8F%8D%E5%BA%8F%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/js/function/2015/06/16/Javascript-%E5%8F%8D%E5%BA%8F%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2.html</guid>
        
        
        <category>js</category>
        
        <category>function</category>
        
      </item>
    
      <item>
        <title>Javascript stop bubble</title>
        <description>&lt;h1 id=&quot;js&quot;&gt;js阻止冒泡方法：&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;var stopBubble = function (e) {
	//如果提供了事件对象，则这是一个非IE浏览器
	if(e &amp;amp;&amp;amp; e.stopPropagation) {
		//因此它支持W3C的stopPropagation()方法
		e.stopPropagation();
	} else {
		//否则，我们需要使用IE的方式来取消事件冒泡 
		window.event.cancelBubble = true;
	}
	return false;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;用法：&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(...).click(function(e){
	stopBubble(e);
});
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 16 Jun 2015 11:20:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/js/common/2015/06/16/Javascript-stopBubble.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/js/common/2015/06/16/Javascript-stopBubble.html</guid>
        
        
        <category>js</category>
        
        <category>common</category>
        
      </item>
    
  </channel>
</rss>
