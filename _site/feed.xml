<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>web前端笔记</title>
    <description>绿螘新醅酒，红泥小火炉。&lt;br&gt;晚来天欲雪，能饮一杯无？
</description>
    <link>http://insekkei.com/blogs//blogs/</link>
    <atom:link href="http://insekkei.com/blogs//blogs/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 27 May 2016 11:18:53 +0800</pubDate>
    <lastBuildDate>Fri, 27 May 2016 11:18:53 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>使用css完成一个三维立体旋转相册</title>
        <description>&lt;p&gt;本篇主要通过这个实践练习transform及3D旋转。&lt;/p&gt;

&lt;p&gt;浏览器中，3D旋转时，主要看x轴、y轴、z轴的方向，旋转所绕的轴是一条横线，为x轴旋转，竖线，为y轴旋转，x和y轴都在显示器所在的平面上。z轴则垂直显示器所在的平面。&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;说到3D，必须提到的一个词：透视，也就是perspective，perspective属性定义3D元素距视图的距离，以像素计，定义观察者在z轴上与3D元素的距离（沿着z轴，与浏览器所在面垂直着，向前走，向后走…，越向前，值越小，越“靠近”3D元素，靠近到0时，看不见了！此刻元素在你脑后！越“远离”，值越大，大到一定程度时，也看不见了！此刻元素已经化身为一个点了…），与之配合的一个属性叫做perspective-origin，两个值，分别定义视角在x轴偏离的角度（从左边向右👉看？从正前方看？从右边向左👈看？）和在y轴偏离的角度（从上边👇俯视？从正前方看？从下边👆仰视？）。&lt;/p&gt;

&lt;p&gt;html代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;stage&quot;&amp;gt;
    &amp;lt;div class=&quot;wrapper&quot;&amp;gt;
        &amp;lt;img src=&quot;http://ww1.sinaimg.cn/large/854f1e58jw1exjhap4pg2j21jk1jku0x.jpg&quot;/&amp;gt;
        &amp;lt;img src=&quot;http://ww3.sinaimg.cn/thumb180/854f1e58jw1f3adtzqrgvj21j01j0x26.jpg&quot;/&amp;gt;
        &amp;lt;img src=&quot;http://tupian.aladd.net/2015/7/2748.jpg&quot;/&amp;gt;
        &amp;lt;img src=&quot;http://ww3.sinaimg.cn/bmiddle/89f08a15gw1f3nc7unjq4j20k00k0dhd.jpg&quot;/&amp;gt;
        &amp;lt;img src=&quot;http://tpic.home.news.cn/xhCloudNewsPic/xhpic1501/M04/0D/54/wKhTlFcr1i-EX9ZYAAAAAG2hseo834.jpg&quot;/&amp;gt;
        &amp;lt;img src=&quot;https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcT7Mf-EWjUIFy77lI2zj2bOyTEcF78SS_AYMo6PfFWzYDQsa_9HEg&quot;/&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;stage是整个3D旋转相册的舞台，wrapper是一组相册的包装元素。&lt;/p&gt;

&lt;p&gt;css代码如下，stage需要设置perspective，wrapper要定义transform-style: preserve-3d。&lt;/p&gt;

&lt;p&gt;对于img，首先通过absolute让一组元素重叠起来，然后分别设置旋转角度，六张图片，角度均匀分布的话，每个应该相差60度，此时六个图片仍然重叠在一起，只是各自面向不同的方位，接下来就是一个重要的设置：translateZ。&lt;/p&gt;

&lt;p&gt;当元素面向浏览器（没有rotateX或者Y）时，translateZ的运动垂直于浏览器所在的平面，而设置了旋转之后，z轴会分别垂直于各个元素旋转之后所在的平面，因此，对于不同方向的img，translateZ相当于让它们像花儿开放一样，手拉手，背对背，分散开来～&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;
    .stage {
        perspective: 800px;
        position: relative;
        height: 400px;
    }
    .wrapper {
        transform-style: preserve-3d;
        height: inherit;
    }
    .wrapper img {
        position: absolute;
        width: 108px;
        height: 108px;
        padding: 10px;
        background: #eee;
        left: 200px;
    }
    .wrapper img:nth-child(1) { transform: rotateY(   0deg ) translateZ(150px); }
    .wrapper img:nth-child(2) { transform: rotateY(  60deg ) translateZ(150px); }
    .wrapper img:nth-child(3) { transform: rotateY( 120deg ) translateZ(150px); }
    .wrapper img:nth-child(4) { transform: rotateY( 180deg ) translateZ(150px); }
    .wrapper img:nth-child(5) { transform: rotateY( 240deg ) translateZ(150px); }
    .wrapper img:nth-child(6) { transform: rotateY( 300deg ) translateZ(150px); }

    @keyframes rotatehaha {
        0% {transform: rotateY(0deg);}
        16% {transform: rotateY(60deg);}
        32% {transform: rotateY(120deg);}
        48% {transform: rotateY(180deg);}
        64% {transform: rotateY(240deg);}
        80% {transform: rotateY(300deg);}
    }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;over。如果要旋转整个相册，给wrapper元素加上transform: rotateY(${num}deg)就可以。自动旋转的话，可以写个小动画：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.wrapper {
    transform-style: preserve-3d;
    height: inherit;
    animation: rotatehaha 10s infinite;
}

@keyframes rotatehaha {
    0% {transform: rotateY(0deg);}
    16% {transform: rotateY(60deg);}
    32% {transform: rotateY(120deg);}
    48% {transform: rotateY(180deg);}
    64% {transform: rotateY(240deg);}
    80% {transform: rotateY(300deg);}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于上边设置的3D相关的属性，可以在浏览器审查元素中通过上下键改变值的大小，感受全方位360度的视角，加深理解…&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zhangxinxu.com/wordpress/2012/09/css3-3d-transform-perspective-animate-transition/&quot;&gt;阅读更多&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 26 May 2016 10:41:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/css3/2016/05/26/%E4%BD%BF%E7%94%A8css%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%89%E7%BB%B4%E7%AB%8B%E4%BD%93%E6%97%8B%E8%BD%AC%E7%9B%B8%E5%86%8C.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/css3/2016/05/26/%E4%BD%BF%E7%94%A8css%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%89%E7%BB%B4%E7%AB%8B%E4%BD%93%E6%97%8B%E8%BD%AC%E7%9B%B8%E5%86%8C.html</guid>
        
        
        <category>css3</category>
        
      </item>
    
      <item>
        <title>react context传值</title>
        <description>&lt;p&gt;用react-router的时候，希望给{this.props.children}这个组件传一个layout里的用户名…&lt;/p&gt;

&lt;p&gt;Layout.js中：&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const Layout = React.createClass({
    childContextTypes: {
        username: React.PropTypes.string
    },
    getChildContext() {
        return {
            username: this.state.username
        };
    },
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;子组件中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const DateRange = React.createClass({
    contextTypes: {
        username: React.PropTypes.string
    },

    ...
    render() {
        const { username } = this.context;
        return ...
    }
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://facebook.github.io/react/docs/context.html&quot;&gt;更多关于context&lt;/a&gt;
&lt;a href=&quot;http://facebook.github.io/react/docs/reusable-components.html&quot;&gt;更多propTypes&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 05 May 2016 17:40:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/context/2016/05/05/react-context.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/context/2016/05/05/react-context.html</guid>
        
        
        <category>react</category>
        
        <category>context</category>
        
      </item>
    
      <item>
        <title>echarts中需要保持legend的selected状态</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;背景：&lt;/h1&gt;

&lt;p&gt;图表随着时间“自动更新”时，假如deSelect了某一项数据，在下次数据来临、图刷新时，依然deSelect这个数据项。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;思路：&lt;/h1&gt;

&lt;p&gt;在公共的Chart组件中：
&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
getInitialState() {
    return {
        selected: {}
    }
},
componentDidUpdate() {
    const el = this.getDOMNode();
    const myChart = echarts.init(el);

    const { selected } = this.state;
    // 如果没有改变select状态，selected将为空
    const ifSelected = this.isEmpty(selected);

    if (ifSelected) {
        myChart.setOption(this.props[&#39;data-source&#39;]);
    }
    else {
        // 手动设置legend.selected
        this.props[&#39;data-source&#39;].legend.selected = selected;
        myChart.setOption(this.props[&#39;data-source&#39;]);
    }

    const _this = this;
    // echarts添加事件监测
    myChart.on(&#39;legendselectchanged&#39;, function(obj) {
        var selected = obj.selected;
        var legend = obj.name;
        _this.setState({
            selected: selected
        });
    });
},
isEmpty(obj) {
    for (var name in obj) {
        return false;
    }
    return true;
},
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://echarts.baidu.com/api.html#events&quot;&gt;更多事件API&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Apr 2016 16:57:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/echarts/2016/04/19/echarts-%E4%BF%AE%E6%94%B9legend%E7%9A%84select%E7%8A%B6%E6%80%81.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/echarts/2016/04/19/echarts-%E4%BF%AE%E6%94%B9legend%E7%9A%84select%E7%8A%B6%E6%80%81.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
        <category>echarts</category>
        
      </item>
    
      <item>
        <title>react native初次会面</title>
        <description>&lt;p&gt;preparation: XCode&lt;/p&gt;

&lt;h1 id=&quot;install&quot;&gt;install&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo npm install -g react-native-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;init-a-project&quot;&gt;init a project&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ react-native init `${projectname}`
$ cd `${projectname}`
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;start&quot;&gt;start&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ react-native run-ios
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;a href=&quot;http://facebook.github.io/react-native/docs/getting-started.html&quot;&gt;read more&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Apr 2016 16:07:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react-native/2016/04/19/first-step-to-reactnative.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react-native/2016/04/19/first-step-to-reactnative.html</guid>
        
        
        <category>react-native</category>
        
      </item>
    
      <item>
        <title>echarts多图时页面resize事件以及重绘需要判断</title>
        <description>&lt;h1 id=&quot;resize&quot;&gt;resize事件&lt;/h1&gt;

&lt;p&gt;当页面上有&amp;gt;1个图表时，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;window.onresize = myChart.resize;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并不能使所有的图响应浏览器resize事件，只有一个随机的图能随着resize。&lt;/p&gt;

&lt;p&gt;于是参考&lt;a href=&quot;https://facebook.github.io/react/tips/dom-event-listeners.html&quot;&gt;DOM Event Listeners in a Component&lt;/a&gt;里所写，添加了resize事件：&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
getInitialState() {
    let innerWidth = window.innerWidth;
    let acWidth;
    if (innerWidth &amp;gt; 991) {
        acWidth = (innerWidth - 144) / 3;
    }
    else {
        acWidth = innerWidth - 60;
    }
    return {
        width: acWidth
    };
},
handleResize() {
    let innerWidth = window.innerWidth;
    let acWidth;
    if (innerWidth &amp;gt; 991) {
        acWidth = (innerWidth - 144) / 3;
    }
    else {
        acWidth = innerWidth - 60;
    }
    this.setState({
        width: acWidth
    });
},
componentDidMount() {
    window.addEventListener(&#39;resize&#39;, this.handleResize);
},
componentWillUnmount() {
    window.removeEventListener(&#39;resize&#39;, this.handleResize);
},
render() {
    const { width } = this.state;
    let option = {
        // 根据echarts配置项手册配置option
    }
    return &amp;lt;Chart data-source={option} height=&quot;300&quot; width={width}/&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，当浏览器窗口缩放时，所有图都会随着重新渲染。但是出现了又一个问题：&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;判断是否需要重新渲染&lt;/h1&gt;

&lt;p&gt;很多时候的重新渲染都是不必要的，如果开启了echarts的animation，就可以看到，页面中其它组件的状态变化也会使echarts重新渲染一遍。&lt;/p&gt;

&lt;p&gt;此时需要&lt;code class=&quot;highlighter-rouge&quot;&gt;shouldComponentUpdate&lt;/code&gt;来限制重绘：&lt;/p&gt;

&lt;p&gt;Chart组件中添加以下代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shouldComponentUpdate: function(nextProps, nextState) {
    let renderFlag = true;

    if ((this.props.width === nextProps.width)
        &amp;amp;&amp;amp; (JSON.stringify(nextProps[&#39;data-source&#39;]) === JSON.stringify(this.props[&#39;data-source&#39;]))) {
        renderFlag = false;
    }
    return renderFlag;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shouldComponentUpdate&lt;/code&gt;的方法返回false时，不重绘。如此，当宽度和数据都没有变化的时候，图将不会重新渲染；页面上图比较多的时候，这样做非常有必要。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;更多关于React-router&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Apr 2016 14:20:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/echarts/2016/04/19/echarts-react-shouldupdate.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/echarts/2016/04/19/echarts-react-shouldupdate.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
        <category>echarts</category>
        
      </item>
    
      <item>
        <title>react router 2使用</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;React Router keeps your UI in sync with the URL. It has a simple API with powerful features like lazy code loading, dynamic route matching, and location transition handling built right in.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;npm--more--&quot;&gt;使用npm安装&lt;!--more--&gt;&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install --save react-router
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;layout&quot;&gt;在Layout中使用&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;A Layout is something that describes an entire page structure, such as a fixed navigation, viewport, sidebar, and footer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import { Link } from &#39;react-router&#39;

...

const Layout = React.createClass({
    ...
    render: function () {
        return (
            &amp;lt;div className=&quot;wrapper&quot;&amp;gt;
                &amp;lt;PlatformHeader/&amp;gt;
                &amp;lt;PlatformNav/&amp;gt;
                &amp;lt;PlatformContent/&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
});

// this.props.children匹配当前加载的内容
const PlatformContent = React.createClass({
    render: function() {
        return (
            &amp;lt;div className=&#39;main&#39;&amp;gt;
                {this.props.children}
            &amp;lt;/div&amp;gt;
        );
    }
});

// PlatformNav中有url链接（路由需求），例如index
var PlatformNav = React.createClass({
    render: function() {
        return (
            &amp;lt;div className=&#39;nav&#39;&amp;gt;
                ...
                &amp;lt;Link to=&quot;index&quot;&amp;gt;首页&amp;lt;/Link&amp;gt;
                ...
            &amp;lt;/div&amp;gt;
        );
    }
});

...
module.exports = Layout;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;index&quot;&gt;index页&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Index = React.createClass({
    render: function() {
        return (
            &amp;lt;div&amp;gt;
                Welcome!
            &amp;lt;/div&amp;gt;
        );
    }
});

module.exports = Index;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;appjs&quot;&gt;在app.js中配置路由&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Layout = require(&#39;./components/Layout&#39;);
var Index = require(&#39;./components/Index&#39;);

// 引入需要的组件
import { browserHistory, IndexRoute, Router, Route } from &#39;react-router&#39;;

// 设置路由，component是组件名称，path写url
const AppRoute = (
    &amp;lt;Router history={browserHistory}&amp;gt;
            &amp;lt;Route path=&quot;/namespace/&quot; component={Layout}&amp;gt;
                &amp;lt;IndexRoute component={Index}/&amp;gt; 
                &amp;lt;Route path=&#39;index&#39; component={Index}/&amp;gt;
            &amp;lt;/Route&amp;gt;
    &amp;lt;/Router&amp;gt;
);

ReactDOM.render(AppRoute, document.getElementById(&#39;xxx&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;更多关于React-router&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 11 Mar 2016 14:40:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/router/2016/03/11/React-Router-2.0.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/router/2016/03/11/React-Router-2.0.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
        <category>router</category>
        
      </item>
    
      <item>
        <title>react router使用</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;React Router keeps your UI in sync with the URL. It has a simple API with powerful features like lazy code loading, dynamic route matching, and location transition handling built right in.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;npm--more--&quot;&gt;使用npm安装&lt;!--more--&gt;&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install --save react-router
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;layoutroutehandler&quot;&gt;在Layout中使用RouteHandler&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;A Layout is something that describes an entire page structure, such as a fixed navigation, viewport, sidebar, and footer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var React = require(&#39;react&#39;);
var RouteHandler = require(&#39;react-router&#39;).RouteHandler;
var Link = require(&#39;react-router&#39;).Link;

...

var Layout = React.createClass({
    ...
    render: function () {
        return (
            &amp;lt;div className=&quot;wrapper&quot;&amp;gt;
                &amp;lt;PlatformHeader/&amp;gt;
                &amp;lt;PlatformNav/&amp;gt;
                &amp;lt;PlatformContent/&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
});

// RouteHandler是react router的核心组件之一，代表与当前路由（url）匹配的组件。
var PlatformContent = React.createClass({
    render: function() {
        return (
            &amp;lt;div className=&#39;main&#39;&amp;gt;
                &amp;lt;RouteHandler/&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
});

// PlatformNav中有url链接（路由需求），例如index
var PlatformNav = React.createClass({
    render: function() {
        return (
            &amp;lt;div className=&#39;nav&#39;&amp;gt;
                ...
                &amp;lt;Link to=&quot;index&quot;&amp;gt;首页&amp;lt;/Link&amp;gt;
                ...
            &amp;lt;/div&amp;gt;
        );
    }
});

...
module.exports = Layout;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;index&quot;&gt;index页&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Index = React.createClass({
    render: function() {
        return (
            &amp;lt;div&amp;gt;
                Welcome!
            &amp;lt;/div&amp;gt;
        );
    }
});

module.exports = Index;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;appjs&quot;&gt;在app.js中配置路由&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Layout = require(&#39;./components/Layout&#39;);
var Index = require(&#39;./components/Index&#39;);

// 引入需要的组件
var Router = require(&#39;react-router&#39;).Router;
var Route  = require(&#39;react-router&#39;).Route;
var DefaultRoute = require(&#39;react-router&#39;).DefaultRoute; // 默认路由，首页

// 或使用es6
import { Router, Route, DefaultRoute } from &#39;react-router&#39;

// 设置路由，handler中是组件名称，path写url
var routes = (
    &amp;lt;Route&amp;gt;
        &amp;lt;Route path=&quot;/&quot; handler={Layout}&amp;gt;
            &amp;lt;DefaultRoute handler={Index}/&amp;gt;
            &amp;lt;Route path=&#39;index&#39; name=&#39;index&#39; handler={Index}/&amp;gt;
        &amp;lt;/Route&amp;gt;
    &amp;lt;/Route&amp;gt;
);

Router.run(routes, Router.HistoryLocation, (Root) =&amp;gt; {
    React.render(&amp;lt;Root/&amp;gt;, document.body);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，点击nav中的“首页”链接时，浏览器地址栏中会出现’index’，同时页面上能看到“Welcome”。而刷新页面时，也能根据给当前url分配的组件Index，加载想要看到的内容。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;更多关于React-router&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Feb 2016 11:40:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/router/2016/02/19/React-Router.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/router/2016/02/19/React-Router.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
        <category>router</category>
        
      </item>
    
      <item>
        <title>IE9不打开控制台无法正常执行js</title>
        <description>&lt;p&gt;接手一个系统项目，必须运行在windows下，浏览器要求IE9。&lt;/p&gt;

&lt;p&gt;调试脚本的过程中使用过&lt;code class=&quot;highlighter-rouge&quot;&gt;console.log()&lt;/code&gt;，同时页面包含一个&lt;code class=&quot;highlighter-rouge&quot;&gt;setInterval()&lt;/code&gt;方法，每隔300毫秒自动获取接口传过来的数据， 获取到正确的数据之后，停止定时器。&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;chrome中测试无误，然而转到IE9中之后，死活无法等到数据，便想打开控制台看看有没有报错，然而每每一打开控制台几乎瞬间数据就传过来了！试了好多次，确定不是机缘未到，抱着怀疑的心理搜索了一下“ie9 控制台打开才执行js”，果然很多人都遇到过这个问题，但是，故事的结局往往出人意料：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;IE仅在开启developer tools的时候，脚本才能访问到console这个对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这真是一个让人忍不住想吐槽的设定…&lt;/p&gt;

&lt;p&gt;对此情况，解决方案有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;生产环境下移除或者注释掉&lt;code class=&quot;highlighter-rouge&quot;&gt;console.log()&lt;/code&gt; 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为避免报错，这样声明&lt;code class=&quot;highlighter-rouge&quot;&gt;console&lt;/code&gt;：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var console = console || {
      log : function () {
          return;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自定义封装个方法调用：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  function log(msg){
      if (window.console){
          console.log(msg);
      }
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多内容：&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/dn255006(v=vs.85).aspx&quot;&gt;https://msdn.microsoft.com/zh-cn/library/dn255006.aspx&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 25 Jan 2016 17:32:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/ie/js/2016/01/25/ie9%E6%97%A0%E6%B3%95%E5%85%BC%E5%AE%B9console%E5%AF%B9%E8%B1%A1.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/ie/js/2016/01/25/ie9%E6%97%A0%E6%B3%95%E5%85%BC%E5%AE%B9console%E5%AF%B9%E8%B1%A1.html</guid>
        
        
        <category>IE</category>
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>css实现背景图片局部滤镜加半透明效果</title>
        <description>&lt;p&gt;实现效果预览：&lt;a href=&quot;http://www.daipuarchitects.com/?cat=14&quot;&gt;Daipu Architects&lt;/a&gt; 中间区域。&lt;/p&gt;

&lt;p&gt;html：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;wrapper&quot;&amp;gt;
    &amp;lt;div class=&quot;overlay&quot;&amp;gt;
        &amp;lt;div class=&quot;overlay-con&quot;&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;父级div，一般背景图会覆盖浏览器可视区域：&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.wrapper{
    ...
    width: 100%;
    height: 100%;
    background: url(image.png);
    background-size: cover;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;模糊背景层，固定宽度，高度为js计算得出，:after设置模糊效果，如果在child上设置，包含文字也会模糊掉:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.overlay{
    ...
    width: 750px;
    position: absolute;
    bottom: 0;
    left: 50%;
    margin-left: -375px;
    background: inherit;
    ...

    &amp;amp;:after {
        content: &quot;&quot;;
        display: block;
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        background: inherit;
        z-index: 0;
        -webkit-filter: blur(3px);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;文字层div：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.overlay-con {
    background: rgba(255,255,255,.6);
    position: relative;
    z-index: 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;总结：没想到&lt;code class=&quot;highlighter-rouge&quot;&gt;background:inherit&lt;/code&gt;会带来这么大的惊喜～&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Jan 2016 17:21:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/css/2016/01/25/css%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E5%9B%BE%E5%B1%80%E9%83%A8%E6%BB%A4%E9%95%9C%E5%8A%A0%E5%8D%8A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/css/2016/01/25/css%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E5%9B%BE%E5%B1%80%E9%83%A8%E6%BB%A4%E9%95%9C%E5%8A%A0%E5%8D%8A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C.html</guid>
        
        
        <category>css</category>
        
      </item>
    
      <item>
        <title>forever守护进程相关记录</title>
        <description>&lt;h2 id=&quot;forever&quot;&gt;安装forever&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install forever -g
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;forever-1&quot;&gt;使用forever&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;用法一：&lt;/h3&gt;

&lt;p&gt;例如：后台定时运行一个phantomjs截图的任务。&lt;/p&gt;

&lt;p&gt;phantmjs截图的代码写在pagename.js中：
&lt;!--more--&gt;
    var page = require(‘webpage’).create();&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;page.open(&#39;pageurl&#39;, function() {
    page.render(&#39;imagePath&#39;);
    phantom.exit();
});
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;定时任务写在capturePage.js中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var childProcess = require(&#39;child_process&#39;);

getImageDaily();

function getImageDaily() {
    getImageByDate(date, function () {
        // 一小时后再更新
        setTimeout(function () {
            getImageDaily();
        }, 60*60000);
    }, function (error, stdout) {
        ...
    });
}

getImageByDate(date) {
    childProcess.exec(&#39;phantomjs pagename.js&#39;, function (error, stdout, stderr) {
        ...
    });
}

app.listen(port || 8888);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;$ forever start capturePage.js&lt;/code&gt;后，查看node进程：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ps aux|grep node

xxx           13169   0.0  0.4  3058580  33252   ??  S     5:02PM   0:00.22 /usr/local/bin/node /Users/baidu/Documents/xxx/capturePage.js
xxx           13168   0.0  0.5  3057732  39420   ??  Ss    5:02PM   0:00.37 /usr/local/bin/node /usr/local/lib/node_modules/forever/bin/monitor capturePage.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;多出了一个monitor的进程，然后，杀死13169即capturePage.js的进程：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kill 13169
$ ps aux|grep node

xxx           13176   0.0  0.4  3058580  33144   ??  S     5:05PM   0:00.22 /usr/local/bin/node /Users/baidu/Documents/xxx/capturePage.js
xxx           13168   0.0  0.5  3057732  39740   ??  Ss    5:02PM   0:00.38 /usr/local/bin/node /usr/local/lib/node_modules/forever/bin/monitor capturePage.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，杀死capturePage.js之后，capturePage.js重启了，进程号不同了。&lt;/p&gt;

&lt;h3 id=&quot;forever-monitorcapturepagejs&quot;&gt;用法二：安装forever-monitor，编码式监控capturePage.js&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install forever-monitor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;新建文档monitor.js：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var forever = require(&#39;forever-monitor&#39;);

var child = new (forever.Monitor)(&#39;capturePage.js&#39;, {
    max: 3,
    silent: true,
    args: []
});

child.on(&#39;exit&#39;, function () {
    console.log(&#39;your-filename.js has exited after 3 restarts&#39;);
});

child.start();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;后台执行monitor.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ node monitor.js &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;优点是，自主可控，缺点是，自己写的，功能不会很完善，当然比不上forever命令，还有日志管理等等。&lt;/p&gt;

&lt;p&gt;资料参考：&lt;a href=&quot;https://github.com/foreverjs/forever-monitor&quot;&gt;forever-monitor&lt;/a&gt;、&lt;a href=&quot;https://github.com/foreverjs/forever&quot;&gt;forever&lt;/a&gt;、&lt;a href=&quot;http://phantomjs.org/screen-capture.html&quot;&gt;phantomjs&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Jan 2016 16:35:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/node/forever/phantomjs/2016/01/25/forever%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/node/forever/phantomjs/2016/01/25/forever%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95.html</guid>
        
        
        <category>node</category>
        
        <category>forever</category>
        
        <category>phantomjs</category>
        
      </item>
    
  </channel>
</rss>
