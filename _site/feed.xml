<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>web前端笔记</title>
    <description>绿螘新醅酒，红泥小火炉。&lt;br&gt;晚来天欲雪，能饮一杯无？
</description>
    <link>http://insekkei.com/blogs//blogs/</link>
    <atom:link href="http://insekkei.com/blogs//blogs/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 05 May 2016 17:45:59 +0800</pubDate>
    <lastBuildDate>Thu, 05 May 2016 17:45:59 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>react context传值</title>
        <description>&lt;p&gt;用react-router的时候，希望给{this.props.children}这个组件传一个layout里的用户名…&lt;/p&gt;

&lt;p&gt;Layout.js中：&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const Layout = React.createClass({
    childContextTypes: {
        username: React.PropTypes.string
    },
    getChildContext() {
        return {
            username: this.state.username
        };
    },
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;子组件中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const DateRange = React.createClass({
    contextTypes: {
        username: React.PropTypes.string
    },

    ...
    render() {
        const { username } = this.context;
        return ...
    }
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Thu, 05 May 2016 17:40:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/context/2016/05/05/react-context.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/context/2016/05/05/react-context.html</guid>
        
        
        <category>react</category>
        
        <category>context</category>
        
      </item>
    
      <item>
        <title>echarts中需要保持legend的selected状态</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;背景：&lt;/h1&gt;

&lt;p&gt;图表随着时间“自动更新”时，假如deSelect了某一项数据，在下次数据来临、图刷新时，依然deSelect这个数据项。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;思路：&lt;/h1&gt;

&lt;p&gt;在公共的Chart组件中：
&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
getInitialState() {
    return {
        selected: {}
    }
},
componentDidUpdate() {
    const el = this.getDOMNode();
    const myChart = echarts.init(el);

    const { selected } = this.state;
    // 如果没有改变select状态，selected将为空
    const ifSelected = this.isEmpty(selected);

    if (ifSelected) {
        myChart.setOption(this.props[&#39;data-source&#39;]);
    }
    else {
        // 手动设置legend.selected
        this.props[&#39;data-source&#39;].legend.selected = selected;
        myChart.setOption(this.props[&#39;data-source&#39;]);
    }

    const _this = this;
    // echarts添加事件监测
    myChart.on(&#39;legendselectchanged&#39;, function(obj) {
        var selected = obj.selected;
        var legend = obj.name;
        _this.setState({
            selected: selected
        });
    });
},
isEmpty(obj) {
    for (var name in obj) {
        return false;
    }
    return true;
},
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://echarts.baidu.com/api.html#events&quot;&gt;更多事件API&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Apr 2016 16:57:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/echarts/2016/04/19/echarts-%E4%BF%AE%E6%94%B9legend%E7%9A%84select%E7%8A%B6%E6%80%81.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/echarts/2016/04/19/echarts-%E4%BF%AE%E6%94%B9legend%E7%9A%84select%E7%8A%B6%E6%80%81.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
        <category>echarts</category>
        
      </item>
    
      <item>
        <title>react native初次会面</title>
        <description>&lt;p&gt;preparation: XCode&lt;/p&gt;

&lt;h1 id=&quot;install&quot;&gt;install&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo npm install -g react-native-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;init-a-project&quot;&gt;init a project&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ react-native init `${projectname}`
$ cd `${projectname}`
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;start&quot;&gt;start&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ react-native run-ios
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;a href=&quot;http://facebook.github.io/react-native/docs/getting-started.html&quot;&gt;read more&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Apr 2016 16:07:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react-native/2016/04/19/first-step-to-reactnative.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react-native/2016/04/19/first-step-to-reactnative.html</guid>
        
        
        <category>react-native</category>
        
      </item>
    
      <item>
        <title>echarts多图时页面resize事件以及重绘需要判断</title>
        <description>&lt;h1 id=&quot;resize&quot;&gt;resize事件&lt;/h1&gt;

&lt;p&gt;当页面上有&amp;gt;1个图表时，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;window.onresize = myChart.resize;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并不能使所有的图响应浏览器resize事件，只有一个随机的图能随着resize。&lt;/p&gt;

&lt;p&gt;于是参考&lt;a href=&quot;https://facebook.github.io/react/tips/dom-event-listeners.html&quot;&gt;DOM Event Listeners in a Component&lt;/a&gt;里所写，添加了resize事件：&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
getInitialState() {
    let innerWidth = window.innerWidth;
    let acWidth;
    if (innerWidth &amp;gt; 991) {
        acWidth = (innerWidth - 144) / 3;
    }
    else {
        acWidth = innerWidth - 60;
    }
    return {
        width: acWidth
    };
},
handleResize() {
    let innerWidth = window.innerWidth;
    let acWidth;
    if (innerWidth &amp;gt; 991) {
        acWidth = (innerWidth - 144) / 3;
    }
    else {
        acWidth = innerWidth - 60;
    }
    this.setState({
        width: acWidth
    });
},
componentDidMount() {
    window.addEventListener(&#39;resize&#39;, this.handleResize);
},
componentWillUnmount() {
    window.removeEventListener(&#39;resize&#39;, this.handleResize);
},
render() {
    const { width } = this.state;
    let option = {
        // 根据echarts配置项手册配置option
    }
    return &amp;lt;Chart data-source={option} height=&quot;300&quot; width={width}/&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，当浏览器窗口缩放时，所有图都会随着重新渲染。但是出现了又一个问题：&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;判断是否需要重新渲染&lt;/h1&gt;

&lt;p&gt;很多时候的重新渲染都是不必要的，如果开启了echarts的animation，就可以看到，页面中其它组件的状态变化也会使echarts重新渲染一遍。&lt;/p&gt;

&lt;p&gt;此时需要&lt;code class=&quot;highlighter-rouge&quot;&gt;shouldComponentUpdate&lt;/code&gt;来限制重绘：&lt;/p&gt;

&lt;p&gt;Chart组件中添加以下代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shouldComponentUpdate: function(nextProps, nextState) {
    let renderFlag = true;

    if ((this.props.width === nextProps.width)
        &amp;amp;&amp;amp; (JSON.stringify(nextProps[&#39;data-source&#39;]) === JSON.stringify(this.props[&#39;data-source&#39;]))) {
        renderFlag = false;
    }
    return renderFlag;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shouldComponentUpdate&lt;/code&gt;的方法返回false时，不重绘。如此，当宽度和数据都没有变化的时候，图将不会重新渲染；页面上图比较多的时候，这样做非常有必要。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;更多关于React-router&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Apr 2016 14:20:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/echarts/2016/04/19/echarts-react-shouldupdate.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/echarts/2016/04/19/echarts-react-shouldupdate.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
        <category>echarts</category>
        
      </item>
    
      <item>
        <title>react router 2使用</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;React Router keeps your UI in sync with the URL. It has a simple API with powerful features like lazy code loading, dynamic route matching, and location transition handling built right in.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;npm--more--&quot;&gt;使用npm安装&lt;!--more--&gt;&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install --save react-router
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;layout&quot;&gt;在Layout中使用&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;A Layout is something that describes an entire page structure, such as a fixed navigation, viewport, sidebar, and footer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import { Link } from &#39;react-router&#39;

...

const Layout = React.createClass({
    ...
    render: function () {
        return (
            &amp;lt;div className=&quot;wrapper&quot;&amp;gt;
                &amp;lt;PlatformHeader/&amp;gt;
                &amp;lt;PlatformNav/&amp;gt;
                &amp;lt;PlatformContent/&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
});

// this.props.children匹配当前加载的内容
const PlatformContent = React.createClass({
    render: function() {
        return (
            &amp;lt;div className=&#39;main&#39;&amp;gt;
                {this.props.children}
            &amp;lt;/div&amp;gt;
        );
    }
});

// PlatformNav中有url链接（路由需求），例如index
var PlatformNav = React.createClass({
    render: function() {
        return (
            &amp;lt;div className=&#39;nav&#39;&amp;gt;
                ...
                &amp;lt;Link to=&quot;index&quot;&amp;gt;首页&amp;lt;/Link&amp;gt;
                ...
            &amp;lt;/div&amp;gt;
        );
    }
});

...
module.exports = Layout;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;index&quot;&gt;index页&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Index = React.createClass({
    render: function() {
        return (
            &amp;lt;div&amp;gt;
                Welcome!
            &amp;lt;/div&amp;gt;
        );
    }
});

module.exports = Index;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;appjs&quot;&gt;在app.js中配置路由&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Layout = require(&#39;./components/Layout&#39;);
var Index = require(&#39;./components/Index&#39;);

// 引入需要的组件
import { browserHistory, IndexRoute, Router, Route } from &#39;react-router&#39;;

// 设置路由，component是组件名称，path写url
const AppRoute = (
    &amp;lt;Router history={browserHistory}&amp;gt;
            &amp;lt;Route path=&quot;/namespace/&quot; component={Layout}&amp;gt;
                &amp;lt;IndexRoute component={Index}/&amp;gt; 
                &amp;lt;Route path=&#39;index&#39; component={Index}/&amp;gt;
            &amp;lt;/Route&amp;gt;
    &amp;lt;/Router&amp;gt;
);

ReactDOM.render(AppRoute, document.getElementById(&#39;xxx&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;更多关于React-router&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 11 Mar 2016 14:40:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/router/2016/03/11/React-Router-2.0.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/router/2016/03/11/React-Router-2.0.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
        <category>router</category>
        
      </item>
    
      <item>
        <title>react router使用</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;React Router keeps your UI in sync with the URL. It has a simple API with powerful features like lazy code loading, dynamic route matching, and location transition handling built right in.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;npm--more--&quot;&gt;使用npm安装&lt;!--more--&gt;&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install --save react-router
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;layoutroutehandler&quot;&gt;在Layout中使用RouteHandler&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;A Layout is something that describes an entire page structure, such as a fixed navigation, viewport, sidebar, and footer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var React = require(&#39;react&#39;);
var RouteHandler = require(&#39;react-router&#39;).RouteHandler;
var Link = require(&#39;react-router&#39;).Link;

...

var Layout = React.createClass({
    ...
    render: function () {
        return (
            &amp;lt;div className=&quot;wrapper&quot;&amp;gt;
                &amp;lt;PlatformHeader/&amp;gt;
                &amp;lt;PlatformNav/&amp;gt;
                &amp;lt;PlatformContent/&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
});

// RouteHandler是react router的核心组件之一，代表与当前路由（url）匹配的组件。
var PlatformContent = React.createClass({
    render: function() {
        return (
            &amp;lt;div className=&#39;main&#39;&amp;gt;
                &amp;lt;RouteHandler/&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
});

// PlatformNav中有url链接（路由需求），例如index
var PlatformNav = React.createClass({
    render: function() {
        return (
            &amp;lt;div className=&#39;nav&#39;&amp;gt;
                ...
                &amp;lt;Link to=&quot;index&quot;&amp;gt;首页&amp;lt;/Link&amp;gt;
                ...
            &amp;lt;/div&amp;gt;
        );
    }
});

...
module.exports = Layout;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;index&quot;&gt;index页&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Index = React.createClass({
    render: function() {
        return (
            &amp;lt;div&amp;gt;
                Welcome!
            &amp;lt;/div&amp;gt;
        );
    }
});

module.exports = Index;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;appjs&quot;&gt;在app.js中配置路由&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var Layout = require(&#39;./components/Layout&#39;);
var Index = require(&#39;./components/Index&#39;);

// 引入需要的组件
var Router = require(&#39;react-router&#39;).Router;
var Route  = require(&#39;react-router&#39;).Route;
var DefaultRoute = require(&#39;react-router&#39;).DefaultRoute; // 默认路由，首页

// 或使用es6
import { Router, Route, DefaultRoute } from &#39;react-router&#39;

// 设置路由，handler中是组件名称，path写url
var routes = (
    &amp;lt;Route&amp;gt;
        &amp;lt;Route path=&quot;/&quot; handler={Layout}&amp;gt;
            &amp;lt;DefaultRoute handler={Index}/&amp;gt;
            &amp;lt;Route path=&#39;index&#39; name=&#39;index&#39; handler={Index}/&amp;gt;
        &amp;lt;/Route&amp;gt;
    &amp;lt;/Route&amp;gt;
);

Router.run(routes, Router.HistoryLocation, (Root) =&amp;gt; {
    React.render(&amp;lt;Root/&amp;gt;, document.body);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，点击nav中的“首页”链接时，浏览器地址栏中会出现’index’，同时页面上能看到“Welcome”。而刷新页面时，也能根据给当前url分配的组件Index，加载想要看到的内容。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;更多关于React-router&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Feb 2016 11:40:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/react/js/router/2016/02/19/React-Router.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/react/js/router/2016/02/19/React-Router.html</guid>
        
        
        <category>react</category>
        
        <category>js</category>
        
        <category>router</category>
        
      </item>
    
      <item>
        <title>IE9不打开控制台无法正常执行js</title>
        <description>&lt;p&gt;接手一个系统项目，必须运行在windows下，浏览器要求IE9。&lt;/p&gt;

&lt;p&gt;调试脚本的过程中使用过&lt;code class=&quot;highlighter-rouge&quot;&gt;console.log()&lt;/code&gt;，同时页面包含一个&lt;code class=&quot;highlighter-rouge&quot;&gt;setInterval()&lt;/code&gt;方法，每隔300毫秒自动获取接口传过来的数据， 获取到正确的数据之后，停止定时器。&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;chrome中测试无误，然而转到IE9中之后，死活无法等到数据，便想打开控制台看看有没有报错，然而每每一打开控制台几乎瞬间数据就传过来了！试了好多次，确定不是机缘未到，抱着怀疑的心理搜索了一下“ie9 控制台打开才执行js”，果然很多人都遇到过这个问题，但是，故事的结局往往出人意料：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;IE仅在开启developer tools的时候，脚本才能访问到console这个对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这真是一个让人忍不住想吐槽的设定…&lt;/p&gt;

&lt;p&gt;对此情况，解决方案有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;生产环境下移除或者注释掉&lt;code class=&quot;highlighter-rouge&quot;&gt;console.log()&lt;/code&gt; 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为避免报错，这样声明&lt;code class=&quot;highlighter-rouge&quot;&gt;console&lt;/code&gt;：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var console = console || {
      log : function () {
          return;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自定义封装个方法调用：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  function log(msg){
      if (window.console){
          console.log(msg);
      }
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多内容：&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/dn255006(v=vs.85).aspx&quot;&gt;https://msdn.microsoft.com/zh-cn/library/dn255006.aspx&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 25 Jan 2016 17:32:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/ie/js/2016/01/25/ie9%E6%97%A0%E6%B3%95%E5%85%BC%E5%AE%B9console%E5%AF%B9%E8%B1%A1.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/ie/js/2016/01/25/ie9%E6%97%A0%E6%B3%95%E5%85%BC%E5%AE%B9console%E5%AF%B9%E8%B1%A1.html</guid>
        
        
        <category>IE</category>
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>css实现背景图片局部滤镜加半透明效果</title>
        <description>&lt;p&gt;实现效果预览：&lt;a href=&quot;http://www.daipuarchitects.com/?cat=14&quot;&gt;Daipu Architects&lt;/a&gt; 中间区域。&lt;/p&gt;

&lt;p&gt;html：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;wrapper&quot;&amp;gt;
    &amp;lt;div class=&quot;overlay&quot;&amp;gt;
        &amp;lt;div class=&quot;overlay-con&quot;&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;父级div，一般背景图会覆盖浏览器可视区域：&lt;!--more--&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.wrapper{
    ...
    width: 100%;
    height: 100%;
    background: url(image.png);
    background-size: cover;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;模糊背景层，固定宽度，高度为js计算得出，:after设置模糊效果，如果在child上设置，包含文字也会模糊掉:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.overlay{
    ...
    width: 750px;
    position: absolute;
    bottom: 0;
    left: 50%;
    margin-left: -375px;
    background: inherit;
    ...

    &amp;amp;:after {
        content: &quot;&quot;;
        display: block;
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        background: inherit;
        z-index: 0;
        -webkit-filter: blur(3px);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;文字层div：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.overlay-con {
    background: rgba(255,255,255,.6);
    position: relative;
    z-index: 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;总结：没想到&lt;code class=&quot;highlighter-rouge&quot;&gt;background:inherit&lt;/code&gt;会带来这么大的惊喜～&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Jan 2016 17:21:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/css/2016/01/25/css%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E5%9B%BE%E5%B1%80%E9%83%A8%E6%BB%A4%E9%95%9C%E5%8A%A0%E5%8D%8A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/css/2016/01/25/css%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E5%9B%BE%E5%B1%80%E9%83%A8%E6%BB%A4%E9%95%9C%E5%8A%A0%E5%8D%8A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C.html</guid>
        
        
        <category>css</category>
        
      </item>
    
      <item>
        <title>forever守护进程相关记录</title>
        <description>&lt;h2 id=&quot;forever&quot;&gt;安装forever&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install forever -g
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;forever-1&quot;&gt;使用forever&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;用法一：&lt;/h3&gt;

&lt;p&gt;例如：后台定时运行一个phantomjs截图的任务。&lt;/p&gt;

&lt;p&gt;phantmjs截图的代码写在pagename.js中：
&lt;!--more--&gt;
    var page = require(‘webpage’).create();&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;page.open(&#39;pageurl&#39;, function() {
    page.render(&#39;imagePath&#39;);
    phantom.exit();
});
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;定时任务写在capturePage.js中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var childProcess = require(&#39;child_process&#39;);

getImageDaily();

function getImageDaily() {
    getImageByDate(date, function () {
        // 一小时后再更新
        setTimeout(function () {
            getImageDaily();
        }, 60*60000);
    }, function (error, stdout) {
        ...
    });
}

getImageByDate(date) {
    childProcess.exec(&#39;phantomjs pagename.js&#39;, function (error, stdout, stderr) {
        ...
    });
}

app.listen(port || 8888);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;$ forever start capturePage.js&lt;/code&gt;后，查看node进程：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ps aux|grep node

xxx           13169   0.0  0.4  3058580  33252   ??  S     5:02PM   0:00.22 /usr/local/bin/node /Users/baidu/Documents/xxx/capturePage.js
xxx           13168   0.0  0.5  3057732  39420   ??  Ss    5:02PM   0:00.37 /usr/local/bin/node /usr/local/lib/node_modules/forever/bin/monitor capturePage.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;多出了一个monitor的进程，然后，杀死13169即capturePage.js的进程：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kill 13169
$ ps aux|grep node

xxx           13176   0.0  0.4  3058580  33144   ??  S     5:05PM   0:00.22 /usr/local/bin/node /Users/baidu/Documents/xxx/capturePage.js
xxx           13168   0.0  0.5  3057732  39740   ??  Ss    5:02PM   0:00.38 /usr/local/bin/node /usr/local/lib/node_modules/forever/bin/monitor capturePage.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，杀死capturePage.js之后，capturePage.js重启了，进程号不同了。&lt;/p&gt;

&lt;h3 id=&quot;forever-monitorcapturepagejs&quot;&gt;用法二：安装forever-monitor，编码式监控capturePage.js&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install forever-monitor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;新建文档monitor.js：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var forever = require(&#39;forever-monitor&#39;);

var child = new (forever.Monitor)(&#39;capturePage.js&#39;, {
    max: 3,
    silent: true,
    args: []
});

child.on(&#39;exit&#39;, function () {
    console.log(&#39;your-filename.js has exited after 3 restarts&#39;);
});

child.start();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;后台执行monitor.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ node monitor.js &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;优点是，自主可控，缺点是，自己写的，功能不会很完善，当然比不上forever命令，还有日志管理等等。&lt;/p&gt;

&lt;p&gt;资料参考：&lt;a href=&quot;https://github.com/foreverjs/forever-monitor&quot;&gt;forever-monitor&lt;/a&gt;、&lt;a href=&quot;https://github.com/foreverjs/forever&quot;&gt;forever&lt;/a&gt;、&lt;a href=&quot;http://phantomjs.org/screen-capture.html&quot;&gt;phantomjs&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Jan 2016 16:35:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/node/forever/phantomjs/2016/01/25/forever%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/node/forever/phantomjs/2016/01/25/forever%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95.html</guid>
        
        
        <category>node</category>
        
        <category>forever</category>
        
        <category>phantomjs</category>
        
      </item>
    
      <item>
        <title>gulp打包编译速度优化</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;保持对新技术的好奇心，深入研究当前工作使用的技术，同时进行一些输出，例如写博客，做开源，研究分享，写书等的，没有输出的学习就是耍流氓。
——来自知乎&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;做项目时使用了browserify，但每次修改编译时间都很长，十几秒的样子？&lt;!--more--&gt;反正感觉等待编译的时间已经远远超过了修改代码的时间，忍无可忍之时，开始寻找解决方案。&lt;/p&gt;

&lt;p&gt;于是很快就找到了watchify，简单理解，就是增量编译。&lt;/p&gt;

&lt;p&gt;修改之前：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var source = require(&#39;vinyl-source-stream&#39;);
var browserify = require(&#39;browserify&#39;);
var streamify = require(&#39;gulp-streamify&#39;);

gulp.task(&#39;browserify&#39;, function () {
    var bundleStream = browserify(&#39;v1/js/app.js&#39;).bundle();

    return bundleStream
    .pipe(source(&#39;app.js&#39;))
    .pipe(streamify(uglify()))
    .pipe(gulp.dest(&#39;./dev/js/&#39;));
});

// after each change, execute browserify, make a long long progress...
gulp.task(&#39;release&#39;, [&#39;browserify&#39;], function () {
    return gulp.src(&#39;./dev/js/app.js&#39;)
    .pipe(gulp.dest(&#39;../static/js/&#39;));
});

// watch everything
gulp.task(&#39;watch&#39;, function () {
    gulp.watch([&#39;v1/less/**/*&#39;], [&#39;css2js&#39;]);
    gulp.watch([&#39;v1/js/**/*&#39;], [&#39;release&#39;]);
});

...
gulp.task(&#39;default&#39;, [&#39;release&#39;, &#39;watch&#39;]);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;添加watchify：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var watchify = require(&#39;watchify&#39;); 
var source = require(&#39;vinyl-source-stream&#39;);
var browserify = require(&#39;browserify&#39;);
var streamify = require(&#39;gulp-streamify&#39;);
var assign = require(&#39;lodash.assign&#39;);

var bundleStream = watchify(browserify(assign({}, watchify.args, {
    // required for watchify
    cache: {},
    // required for watchify
    packageCache: {},
    entries: [&#39;v1/js/app.js&#39;]
}))); 

gulp.task(&#39;browserify&#39;, bundle);
// on any dep update, runs the bundler
bundleStream.on(&#39;update&#39;, bundle);
// output build logs to terminal
bundleStream.on(&#39;log&#39;, gutil.log);

function bundle() {  
  return bundleStream.bundle()
    // log errors if they happen
    .on(&#39;error&#39;, gutil.log.bind(gutil, &#39;Browserify Error&#39;))
    .pipe(source(&#39;app.js&#39;))
    .pipe(streamify(uglify()))
    .pipe(gulp.dest(&#39;./dev/js/&#39;));
}

// browserify will not need
gulp.task(&#39;release&#39;, function () {
    return gulp.src(&#39;./dev/js/app.js&#39;)
    .pipe(gulp.dest(&#39;../static/js/&#39;));
});

gulp.task(&#39;watch&#39;, function () {
    gulp.watch([&#39;v1/less/**/*&#39;], [&#39;css2js&#39;]);
    // just watch one file produced by WATCHIFY
    gulp.watch([&#39;./dev/js/app.js&#39;], [&#39;release&#39;]);
});

...
// only at the beginning browserify being executed
gulp.task(&#39;default&#39;, [&#39;browserify&#39;, &#39;watch&#39;]);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;延伸阅读及参考资料：&lt;/p&gt;

&lt;p&gt;http://csspod.com/advanced-tips-for-using-gulp-js/&lt;/p&gt;

&lt;p&gt;http://csspod.com/using-browserify-with-gulp/&lt;/p&gt;
</description>
        <pubDate>Mon, 21 Dec 2015 11:28:00 +0800</pubDate>
        <link>http://insekkei.com/blogs//blogs/gulp/browserity/2015/12/21/gulp%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96.html</link>
        <guid isPermaLink="true">http://insekkei.com/blogs//blogs/gulp/browserity/2015/12/21/gulp%E6%89%93%E5%8C%85%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96.html</guid>
        
        
        <category>gulp</category>
        
        <category>browserity</category>
        
      </item>
    
  </channel>
</rss>
